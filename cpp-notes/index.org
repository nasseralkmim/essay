#+title: C++ notes
#+date: <2021-04-02 Fri>
#+lastmod: 2021-08-03 18:36:39
#+author: Nasser Alkmim
#+email: nasser.alkmim@gmail.com
#+tags[]: c++ 
#+draft: t
#+toc: t
* Introduction

These are my notes about C++.
Mostly experiments and running examples with =org-babel= within Emacs.

Ideally, if you want to benefit from this, you should write, run, and understand the examples yourself.

If you don't know about =org-mode= with =org-babel=, it is an Emacs package that allows prose and code execution (multiple languages) within the same file.
It is extremely powerful and useful as a learning tool and also to create literate programming narratives or prototypes.


* Advice
** General
1. state *intent* in comments, don't say what can be stated in code
   1. what is the intention behind this block of code? *why* are you doing? the code itself describes thew *how* you are doing
   2. via negative: don't describe your code 
2. don't declare variable until you have a value to initialize it with (same reason as 5)
   1. avoid crashes and wrong outputs by "access through uninitialized pointers and out-of-range access"
3. avoid uninitialized variables
   1. because if we try to use the variable before it was initialized the compiler would give an undefined behavior
   2. initialize means assign a value
   3. the construct ensures that every object of a class is initialized
   4. [[*Type safety][Type safety]]
4. avoid narrowing conversions (?)
   1. conversion of types (?)
5. function should be short and perform one task
6. one name per declaration (?)
7. avoid magic constants, use symbolic constants (?)
8. ={}= for initializer an object with values and lists
   1. /indicates construction/ and avoid confusion with function arguments.
   2. instead of =()= for function call and =[]= which indicates array.
   3. exceptions common because of old habits: simple initialization with === and =()= for number of elements in vectors.
      1. === was kept from C language, but it confuses with an assignment
9. public interface and implementation of a class should be separated
10. avoid over use of parenthesis
11. balance between obscure trickery and boring prolixity
12. avoid =new= outside constructor
    1. avoid memory leak if forget to delete the =new= created
    2. =delete= inside destructors
13. avoid implicit conversion withing a class constructor
    1. better use the =explicit= when initializing with single argument
       
** Programming practices
1. approach a task with gradual refinement
   1. constantly test enhancements
2. "compile" does not mean works correctly
3. avoid unnecessary copying by passing vectors and matrices by reference
4. always use =const= to protect unintended data modification
5. limit to few data types, =int= and =double= for instance
6. express the thought-process in code explicitly, not implicitly (just on your head) -- Bjarne Stroutstrup (Lex Friedman interview 2019)
** Naming conventions
1. UserDefinedTypes
2. variable_names
3. class_data_members_
4. struct_data
5. kConstantVariables
6. FunctionNames
7. namespaces_names
1. avoid ALL_CAPS
2. common and local names short and nonlocal longer
9. avoid long member functions definitions (bodies) inside classes declarations
   
* Technicalities
** Declarations and definitions
Declaration _introduces a name_ into a scope.
It is different from *defining* something.
A _declaration that specifies_ the entity is a *definition*.

*Before a name can be used it must be declared.*

Declarations specify type and, optionally, an initializer (initial value).
It defines how something can be used, when not interested in implementation details.
Declarations do not consume memory, whereas definitions do.
This is why C++ uses it, for efficiency purposes.

*Declarations must be consistent.*
A declared function can not return double and int.

#+begin_src C++
#include <iostream>

int main() {
  int a = 1;			// a is the name of this declaration, 1 is the initial value
}
#+end_src

** Headers files
*** Definition
It is a file, =.h=, that helps us to manage _declarations_ of facilities defined elsewhere.
Those files are included with =#include=.

The _definition_, usually, is written elsewhere.
The uses also are usually written in another file.

If we want to use a function that was defined in =widget.cpp= in =main.cpp= we need to =#include widget.h=, which is the header file with the _declaration_.

*** What should be in the header files?

Public interface.
If something is in the header (declared) but not implemented (defined), then the linker will raise errors.
If something is defined but the header declared it differently, the compiler will raise errors.

*** Why not put everything in the header file?

Because when you include a header file, the compiler will read it and compile it.
If you use the definition in multiple other files, every time you include it, the compile will work.
This makes compile time slow.

*** What the concepts interface and implementation stand for?

Most libraries are distributed with an _interface_, the header files with declaration, and the _implementation_, actual =.cpp= with all definition.

*** What is the deal with "header only libraries"?

A header only library is distributed only as with header files.

With these libraries there is no need to build any binary (executable) to use them.

Usually _template libraries_, standard template library, is a header only library.
Those are compiled only when we use the templates in our own code.

Benefits of header only libraries:
1. no need to build the library (compile code into executables).

** Namespace

Allow us to identify part of a program without defining a type.
A name is composed by the namespace name and a member name combined with =::=, this is a fully qualified name.
With =namespace= we can group named entities, useful to narrow scope of naming.

#+begin_src C++
#include <iostream>

namespace identifier {
  int a = 10; // name "a" is narrowed in scope by the identifier
} // namespace identifier

int main() { std::cout << identifier::a; }
#+end_src

#+RESULTS:
: 10

A shorthand can be used to avoid typing the namespace name every time with =using namespace "name"=.
This way the name becomes directly available for use.

** Operators
*** Logical operators (!, &&, ||)

=!= boolean for NOT.
If its operand on its right is true, =!= turns it into false.

=&&= means AND and =||= means OR.

#+begin_src C++
#include <iostream>
using namespace std;

int main() {
  if (!false) {cout << "ok";}
}
#+end_src

#+RESULTS:
: ok

*** Compound assignments (+=, *=)

Modify current value of variable.

#+begin_src C++
#include <iostream>
using namespace std;

int main() {
  int a, b = 3; // b is initialized with a value 3
  a = b;        // assign b value to a
  a += 2;       // equivalent to a=a+2
  cout << a;
}
#+end_src

#+RESULTS:
: 5
*** Member access operators (., ->)

Use =.= to access a member of a class.
Use =->= to access a member through a pointer.

See [[*Accessing elements][Accessing elements]] for example.

*** Conditional ternary (?)

Conditional operator =?= evaluates an expression, returning first value if true and second if false.

#+begin_src C++
#include <iostream>
using namespace std;

int main() {
  int a, b, c;

  a = 2;
  b = 7;
  c = (a > b) ? a : b; // false, so return return b, then c=7

  cout << c << '\n';
}
#+end_src

#+RESULTS:
: 7

*** Scope resolution (::)
To access a certain scope

*** Math operators

#+begin_src C++
#include <iostream>

int main () {
  int n = 3;
  if (n & 1)
    std::cout << n % 2;
}
#+end_src

#+RESULTS:
: 1

** Bitwise left and right shift (<<, >>)

These operators shift bits.

All information is stored in the computer in a bit form.
For 32-bit storage system, there are 32 bits and each can be 0 or 1.
1 byte is equivalent to 8-bits.
Shifting a bit means shifting the 0 and 1 pattern to left or right.


The right shift operator =>>=




** Semicolon
1. after class and structure definitions
2. after variable declaration
3. after function declaration
4. does not need
   1. after main function
   2. after function definition in general
   3. after the constructor of a class (which is a function)

#+begin_src C++
#include <iostream>

void func_declaration (int x); // DECLARE a function requires ;
void func_declaration(int x) {    // defines a function
  int y = x;
}				     // DEFINE a function does not requires ;
int main() { func_declaration(10); } // does not require ;
#+end_src

#+RESULTS:
** Move semantics
*** What is the difference =rvalues= and =lvalues=?

=rvalues= correspond to *temporary* _objects returned from functions_.

=lvalues= correspond to objects you can refer by _name_ or by _following a pointer_ or _=rvalue= reference_.
For =lvalues= you can, generally, get its address, we say that /it can be addressed/.

=rvalues= are eligible for move operations, =lvalues= are not.
Move constructors are useful to avoid copying the object when the initialization is done with a function return.
This improves performance.

For instance, in =int var = foo(arg)=, =var= is /lvalue/ because it has a name and can be addressed and =foo(arg)= is an /rvalue/. 


#+begin_src C++
#include <iostream>

void widget (int& v){}
void widget2 (int&& v){}

int main() {
  int a = 1;
  widget(a);			// allowed, a has an address
  // widget(10);                // error 
  widget2(10);			// allowed, widget2 recieves rvalue reference &&
}
#+end_src

#+RESULTS:

Remarks:
1. error: =cannot bind non-const lvalue reference of type ‘int&’ to an rvalue of type ‘int’=.
   1. because the =10= is an rvalue with no address to be referenced.
2. when =widget2() is called= it accepts the rvalue 10 because of the =&&= rvalue reference operator.

*** What is the difference between /move operator/ and /copy operator/?

When creating an _new object_ by calling the constructor, the _source object_ passed to the constructor can have its members fields /copied/ or /moved/ into the new object.

A /copy constructor/ does not change the source object.
Therefore it allocates its own copy of the object data in memory.
Then, there will be the same data in two locations in memory.

A /move constructor/ just "move" the data by using the pointer that refers to it.
The new object now refers to the original data in memory.
This makes this constructor *more efficient* because the data is located at only one place in memory.

#+begin_src C++
#include <iostream>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

void print_vec(std::vector<int> v) {
  std::cout << "[";
  for (auto elem: v) {std::cout << elem << ", ";}
  std::cout << "]" << std::endl;
}
 
class Widget {
public:
  int var;
  std::vector<int> vec;

  Widget(int a, std::vector<int> v) : var{a}, vec{v} {} // constructor

  void print(std::string label) {
    std::cout << "obj: " << label << "\n stored in: " << &var << " with value: " << var << "\n";
    std::cout << " vector stored in: " << vec.data() << " value: ";
    print_vec(vec);
  }
};

int main (){
  Widget obj1(10, {1, 2, 3, 4});
  obj1.print("1 original");

  std::cout << "\n COPY" << std::endl; 
  auto obj2 = obj1;		// make a COPY!
  obj2.print("2");		// SAME value, DIFFERENT memory location
  obj1.print("1 after been copied");

  std::cout << "\n MOVE" << std::endl; 
  obj1.print("1 original");
  auto obj3 = std::move(obj1);	// MOVE constructor
  obj3.print("3");		// only vecotr SAME MEMORY location
  obj1.print("1 after beed moved");
}
#+end_src

#+RESULTS:
#+begin_example
obj: 1 original
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]

 COPY
obj: 2
 stored in: 0x7ffc6ae19530 with value: 10
 vector stored in: 0x562d437bdeb0 value: [1, 2, 3, 4, ]
obj: 1 after been copied
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]

 MOVE
obj: 1 original
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]
obj: 3
 stored in: 0x7ffc6ae19550 with value: 10
 vector stored in: 0x562d437bded0 value: [1, 2, 3, 4, ]
obj: 1 after beed moved
 stored in: 0x7ffc6ae19510 with value: 10
 vector stored in: 0 value: []
#+end_example

Remarks:
1. when copying, data is copied to another address
   1. the _value is the same_ but it is stored in a _different memory address_
   2. nothing changes with the original object
2. when moving, the data moves to another object
   1. the vector gets the _same address and value_ as the original one
   2. the integer is copied because it is small and cheap, so it gets a new address
   3. the original object has _no more vector data_ (=nullpointer= and value)
      
** Type safety
When each object has a type and are used according to the rules for their type.
Avoid uninitialized variables so the type is clear.

#+begin_src C++ 
int main () {
double x;			// declares WITHOU INITIALIZING!
double y = x;			// value of y still undefined
double z = 2.0 + x;		// meaning of "+" and the value of z are undefined!
}
#+end_src

#+RESULTS:

** TODO Overloading

** =const= correctness

Using =const= makes the code more readable.
When you see a =const= before a function you know it will not change the object.

=const= arguments in functions make them more general.
We can pass a non constant variable to a function that expects a =const= argument, but we can not pass a =const= value to a function with non-constant arguments.
** Passing parameter by value

Passing a parameter by value implies that the function will make a copy of it.
This allows we make any changes we want to the variable.
However it is error prone an hard to read.

If you want pass an input variable only, make it =const.=

#+begin_src C++
#include <iostream>
#include <ostream>

void foo(int arg) {
  arg = arg * 2;
  std::cout << arg << std::endl;
}
int main() {
  int a{1};
  foo(a);			// modified a inside foo
  std::cout << a;		// original a unchanged
}
#+end_src

#+RESULTS:
: 2
: 1

* Basics
** Minimal program
Defines a function with no arguments, empty (), and does nothing, empty {}.

Every program needs a =main= function.
The =int= is the value returned by the function.

#+begin_src C++
int main () {}
#+end_src

#+RESULTS:

** Hello world

Include the declarations of the standard stream I/O facilities.
Operator =<<= writes the second argument (string) to the first (standard output stream =std:cout=).
The =std::= indicates that it is in the standard library namespace.
If does not want to write every time, add =using namespace std;= in the beginning of file.

#+begin_src C++
#include <iostream>

int main() {
  std::cout << "Hello";
}
#+end_src

#+RESULTS:
: Hello

** Functions

A function is declared with its name, type of the returned value, number and types of arguments.

#+begin_src C++
#include <iostream>
using namespace std;

double square (double value) {
  return value * value;
}

int main () {
  cout << square(10);
}
#+end_src

#+RESULTS:
: 100

** Scope
Scopes can be started with curly braces ={}.=
Any objects that are declared within the scope are allocated in memory only during the execution of that scope.


Local scope: declarations in a function.

Namespace scope: a name is /namespace member name/ if it is declared outside any function.
Its scope extends from the point of declaration to the end of its namespace.

There are objects without a name, temporary objects created with =new=


#+begin_src C++
#include <iostream>
#include <vector>
using namespace std;

vector<int> vec; 		// GLOBAL vector of integers

void fct (int arg) {
  string motto {"Something"}; 	// LOCAL variable
}

int main () {
  vec.push_back(10);		// add 10 to the vector
  cout << vec[0];		// vec first entry
}
#+end_src

#+RESULTS:
: 10

** Pointers

The operator =*= means "pointer to", also understood as "contents of"
A pointer variable _holds the address_ of an object.
The address can be used to access a value.

The symbol =&= means "address of".

#+begin_src C++
#include <iostream>
using namespace std;

int main () {
  int v[6] = {1, 1, 1, 9, 1, 1};			// array of 6 int from 0 to 5
  cout << v[3] << endl;
  int* p = &v[3];			// p points to v 4th element ADDRESS
  cout << p << endl;			// prints the memmory address
  int x = *p;			// *p is the object that p points to... meaning the 4th array element
  cout << x << endl;
  int* y = p;			// pass the ADDRESS to another pointer
  cout << y;
}
#+end_src

#+RESULTS:
: 9
: 0x7ffc231cc0ac
: 9
: 0x7ffc231cc0ac

** =new= operator

_Returns a pointer_ to the object it creates.
If it creates multiple objects it returns a pointer to the first.

About memory.
1. the =new= operator allows the program to use the _free store memory_, or /heap/
2. if you don't delete the pointer it causes _memory leak_
3. as alternative to use the operator, the object creation could use stack memory (local variables)
   1. if too many object are allocated it risks _stack overflow_

Notes:
1. =[]= indicates array
2. ={}= initialize variable preferred way instead of =()=

#+begin_src C++
#include <iostream>
#include <ostream>

int main() {
  double *p = new double[4]; // creates a variable p which is a pointer
  std::cout << p << std::endl;	     // new returns the pointer to the first of the array of double
  int *pi = new int;		     // new integer pointer to pi
  std::cout << pi << std::endl;
  double *p2 = new double{5.5}; // initialize with {}, p2 points to memory
                                // address that has 5.5 as value
  std::cout << "Address: " << p2 << " value: " << *p2;
}
#+end_src

#+RESULTS:
: 0x55be16a1beb0
: 0x55be16a1cef0
: Address: 0x55be16a1cf10 value: 5.5

** =const= operator
*** =const= variable
As the name suggests, it makes the variable unchangeable.

On the other hand, =constexpr= are evaluated at compile time.
Allows placement of data for read only, improving performance.

#+begin_src C++
#include <iostream>
using namespace std;

const int dmv = 17;
constexpr double max1 = 1.2 * dmv;

int main () {
    cout << max1;
}
#+end_src

#+RESULTS:
: 20.4
*** =const= pointer

If =const= is AFTER =*= we can not change the _pointer content_, but pointer itself we can.
We can understand as the operator qualifying the symbol of the pointer.

If =const= is BEFORE =*= we can change the pointer itself, but not the content.
Understand as =const= operator qualifying the =*= which indicates the pointer target.

#+begin_src C++
#include <iostream>
#include <ostream>

int main() {
  int *const pt = new int; // const after -> pointer itself constant
  *pt = 12030;             // change pointer content, ALLOWED!
  std::cout << "pointer: " << pt << " points to: " << *pt << std::endl;
  // pt = new int;			// error: assignment of read-only
  // variable ‘pt’
  int const *pt2 = new int; // conts before -> content constant
  pt2 = new int;            // change pointer itself ALLOWED!
  std::cout << "pointer: " << pt2 << " points to: " << *pt2 << std::endl;
  // *pt2 = 12039;			// error: assignment of read-only
  // location ‘* pt2’
}
#+end_src

#+RESULTS:
: pointer: 0x5604e06d3eb0 points to: 12030
: pointer: 0x5604e06d4f00 points to: 0
*** =const= function argument

Function argument is only readable.
*** =const= after the arguments of a member function

In a class definition.
The whole member function can be =const=, meaning that the function can not change object member variable.

#+begin_src C++
#include <iostream>
class MyClass {
  public:
  int var;
  void func1 () {var = 1;}	// change member variable ALLOWED!
  // void func2 () const {var = 1;} // error: assignment of member varialbe in READ-ONLY object
};

int main() {
  MyClass obj; 
}
#+end_src

#+RESULTS:

** Declarator operators

1. =T a[n];= array named "a" of n Ts (type)
2. =T* p;= pointer to T
3. =T& r;= reference to T
4. =T f(A);= function taking argument of type A and returning a result of type T

** Range-for-statement

For loops that go over a sequence.
Does not need a counting variable.

#+begin_src C++
#include <iostream>
using namespace std;

void print () {
  int v[] = {0, 1, 3};		// create array
  for (auto x : v)
    cout << x << "\n";
}
int main () {
  print();			// call function
}
#+end_src

#+RESULTS:
: 0
: 1
: 3

** Tests

If statements.

#+begin_src C++
#include <iostream>
using namespace std;

int main (){
  int answer = 2;
  if (answer == 2)
    cout << answer;
}
#+end_src

#+RESULTS:
: 2

** Variable initialization

Use ={}= to initialize.

#+begin_src C++
#include <iostream>

double fun(double float_arg) {
  int a = float_arg; // converts float into int () (BAD!)
  std::cout << a << std::endl;
  int b{float_arg};		// error: possile truncation (GOOD!) compiler works but...
  std::cout << b << std::endl;
  double c{float_arg}; // better to correcly specify the type
  std::cout << c << std::endl;
  return a;
};

int main () { fun(1.3209);}
#+end_src

#+RESULTS:
: 1
: 1
: 1.3209

** =cout= versus =printf=

1. =cout= is C++ and =printf= is C but it can be used in C++.
2. =cout= is extensible.
3. =printf= uses standard function syntax.
4. C++ FAQ suggests using <iostream> =cout= instead of <cstdio> =printf=;
   1. increase type safety, reduce errors, allow extensibility, provide inheritability.

#+begin_src C++ :includes <iostream>
int a=1;
int b=1;
std::cout << a+b << "\n";
printf("%d\n", a+b);
#+end_src

#+RESULTS:
: 2
: 2

** How many bytes?

Number of _bytes_ to store an information type.
This number of bytes is required to storage the specific object in memory.
The computer memory can be viewed as a sequence of _bytes_ 0 and 1.

#+begin_src C++ :includes <iostream>
std::cout << sizeof(int) << std::endl;
std::cout << sizeof(double) << std::endl;
std::cout << sizeof(bool) << std::endl;
#+end_src

#+RESULTS:
: 4
: 8
: 1

* Pointers
** Memory

Computer memory is a sequence of bytes.
The location in memory is the specific byte position in the sequence, called _address_ of the byte.
Everything in memory has an address.

The type of variable will define the memory size required to store that variable type.
The amount of memory can be viewed with =sizeof= operator.

#+begin_src C++
#include <iostream>
#include <ostream>

int main () {
  int x = 17; // define integer
  int *pi = &x; // definer a /pointer to int/ with the address of x
  std::cout << pi << std::endl;
  std::cout << sizeof(pi);	// size of a pointer to integer
}
#+end_src

#+RESULTS:
: 0x7ffdde0a297c
: 8

** Pointer definition

_A pointer is an object that holds a memory address value._
A pointer can "point" to anything that can be placed in memory.
We can refer to it as "values in" the pointer.

** Pointer type
The type needed to hold an address of a type is specified with =<type>*=.
For instance, the type that holds a pointer to an =int= is =int*=, which can be referred to as "pointer to int type", or "int pointer type".

To create a pointer type object we can use =&= to get an address or =new= to generate one.
** "Address of" operator (&)
_A pointer is a variable that stores the address of another variable._

Variables are locations in computer memory which are accessed by an identifier (name).

Memory is a succession of cells with one byte in size with an unique address.

It may be useful to get the memory address of a variable during runtime.
With this address we can access other data cells with a specific relative position.

The address of a variable is obtained with the operator =&=.
Other alternative to get a pointer is to use the operator =new= when creating an object.

#+begin_src C++
#include <iostream>
using namespace std;

int main ()
{
  int var = 10;
  int *address_of_var = &var;	// * indicates that this variable is a pointer
  cout << address_of_var;	// memmory address of variable var
}
#+end_src

#+RESULTS:
: 0x7ffc1a43fc2c

** "Contents of" operator (*)

Pointers have the addresses.
This address may be populated with a variable value.
So, pointers can be used to _access the variable they point to_.

The operator =*= means "value pointed to by".
Also called /dereference/ operator and /indirection/ operator.
We can use it to change the _content of an object through a pointer_.
   
#+begin_src C++
#include <iostream>

int main () {
  int var = 2;
  int* var_pointer = &var;		// stores the address to var
  std::cout << var_pointer << "\n";		// pointer refers to ADDRESS
  int c = *var_pointer;			// * get the VALUE THAT THE ADDRESS is pointing to (2)
  std::cout << c;
}
#+end_src

#+RESULTS:
: 0x7ffdcb5ee548
: 2

** Access object pointed to by a pointer

We can use the operator =*= or =[]= to access an object /pointed to by a pointer/.
We can then use the pointer to change the _content_.

#+begin_src C++
#include <iostream>
#include <ostream>
int main(){
  int x = 10;
  std::cout << "original object: " << x << std::endl;
  int*p = &x;			// p points to address of x
  *p = 7;			// change object content through a pointer
  std::cout << "changed object: " << x << std::endl;
  
}
#+end_src

#+RESULTS:
: original object: 10
: changed object: 7

** Null pointer

When you don't have any pointer to use to initialize a pointer you can use =double* ptr = nullptr;=

=if(ptr)= checks if the pointer is valid, non =nullptr=.
Using =0= and =NULL= is deprecated in favor of the new =nullptr= which is mode specific and clear.

** References

A reference is a immutable pointer.

When the operator =&= is in the type instead of in the initializer we _create a reference_.

When we want to change the original referenced content we don't need the =*= like in with the pointer.
Therefore, a reference acts just like the variable itself, like an *alias*.

1. change the referenced content without =*=
2. read referenced content without =*=
3. CAN NOT change the reference address
   1. there is no way to get a reference to refer to a different object after initilization
   2. if there is a need to point to something different, a pointer should be used

#+begin_src C++
#include <iostream>
#include <ostream>

int main() {
  int var1 = 10;
  std::cout << "va1: " << var1 << std::endl;
  int& ref1 = var1;		// create reference to var1
  std::cout << "ref1: " << ref1 << std::endl;
  ref1 = 7; // change the content through the reference WITHOUT *
  std::cout << "ref1: " << ref1 << std::endl;
  std::cout << "var1 changed through ref1: " << var1 << std::endl;
  
  int var2 = ref1;			// read var1 through ref1 WITHOUT *
  std::cout << "var2: " << var2 << std::endl;
  int& ref2 = var2;		// create reference to var2
  var1 = 1;
  ref2 = ref1;			// CHANGE THE VALUE of VAR2 using ONLY references
  std::cout << "var2: " << var2 << std::endl;
  // ref1 = &var2;			// error: invalid conversion from ‘int*’ to ‘int’
}
#+end_src

#+RESULTS:
: va1: 10
: ref1: 10
: ref1: 7
: var1 changed through ref1: 7
: var2: 7
: var2: 1

** When to use references

References are just like an *alias* for an object.
The reference has no information about the lifetime of the object, which can be automatic within a scope or manually allocated in the heap (free memory).

The usage of references are preferred to pointers.

An example is when we need to pass function arguments.
We can (i) pass by value, (ii) pass by reference.

If we pass large objects as values it can impact the performance.

#+begin_src C++
#include <iostream>
#include <ostream>

class A {
public:
  int var = 10;
};
void f(A& ref) { // f receives A instance ITSELF, CAN BE MODIFIED
  ref.var = 2;   // change instance
}

void f2(A ref) { // f receives COPY of passed instance of A
  ref.var = 20;
}
int main() {
  A a;				// create instance of A
  std::cout << "original var: " << a.var << std::endl;
  f(a);				// call function with REF
  std::cout << "passed as reference: " << a.var << " CHANGED the instance!" << std::endl;
  f2(a);
  std::cout << "passed as value: " << a.var << " DOES NOT CHANGE the instance!";
}
#+end_src

#+RESULTS:
: original var: 10
: passed as reference: 2 CHANGED the instance!
: passed as value: 2 DOES NOT CHANGE the instance!

** Pointer and reference parameters

With the goal of changing the value of a variable to a value computed by a function we have 3 choices:
1. pass the value to the function and return it
2. pass a pointer
3. pass a reference

Passing a value is clear and simple when the *object is small*.
For large objects, pointers and references offer a more efficient alternative.

The main difference between a pointer or reference in this case is when the pointer is passed, it is required to use the operator "address of", =&=, to get the pointer.
This is a visual cue that represents a _situation where the variable value may change_.
Whereas passing a reference is not much different than passing the variable itself.

Rule-of-thumb:
1. small objects: pass-by-value.
2. function that accept "no object" use pointer parameter and manually handle the null pointer case.
3. otherwise: use reference parameter.

#+begin_src C++
#include <iostream>
#include <ostream>

int incr_v(int x) {return x + 1;}
void incr_p(int* p) {++*p;}	// passing the pointer and changing pointer content itself
void incr_r(int& r) {++r;}	// passing a reference and changing the content itself

int main() {
  int x = 2;
  x = incr_v(x);			// passing the VALUE and REASSINGN to the variable
  std::cout << "value reassingned: " << x << std::endl;

  incr_p(&x);			// passing the pointer using & to get the address of x
  std::cout << "value changed by the function using pointer: " << x << std::endl;

  incr_r(x);
  std::cout << "value changed by the function using reference: " << x << std::endl;
}
#+end_src

#+RESULTS:
: value reassingned: 3
: value changed by the function using pointer: 4
: value changed by the function using reference: 5

** Protecting data "pointed to" when passing by reference

Problem:
When passing by reference, even with =const=, we can change the data "pointed to".

# The book: Numerical recipes says that we can change the vector element through the assignment via the =operator[]= in a reference variable.
# But my compiler does not allows that.

#+begin_src C++
#include <iostream>
#include <ostream>
#include <vector>

void foo(int &a, std::vector<int> &vec) {
  a = a * 2; // Can not modify const int reference
  vec[1] = 1999;		// modify vector through REFERENCE!
}
int main() {
  int a{19};
  std::cout << a << std::endl;
  std::vector<int> vec {1, 2};
  std::cout << vec[1] << std::endl;
  foo(a, vec);
  std::cout << vec[1] << " vec element modified!"<< std::endl;
  std::cout << a << " a modified! "<< std::endl;
  
}
#+end_src

#+RESULTS:
: 19
: 2
: 1999 vec element modified!
: 38 a modified! 

Remarks:
1. when the function receives =const= argument it CAN NOT modify them.
   1. even with =[]=
   2. even if is a references to a vector.
2. variable =a= passed by reference to function with =&= is subject to modification!

* Classes
** Definitionss
*** Class and objects

A class type specify _how the object of its type are represented, how are they used and how they can be destroyed._

A class creates an _object blueprint_.

An object is an _instance of the class_.
When the class is called you create an instance of the object.

*** Types
Types are a way to representing ideas in code.
A type knows how to represent the data in an object and which operations can be applied to it.

*** User defined type (UDT)
*User defined types* (UDT) can be used to implement high level facilities.
These types are built out of the built-in types and C++ abstraction mechanisms.
User defined types that C++ provides are: classes and enumerations.

*** Built in types (BIT)
*Built in* types (BIT) are recognized by the compiler without any declaration supplied by the programmer.

*** Standard librar types (SLT)
*Standard library types* (SLT) such as string, vector, ostream are considered user-defined types (UDT).
These types are part of C++ ISO standard implementation.
These are considered UDT because they are constructed from the same primitive as the UDT.

*** Defining and instantiating an object

When the blueprint of an object is created we are defining it.
When we call the blueprint we instantiate an object.

*** Uses of classes
1. grouping functions
   1. one class with multiple close related functions
   2. eg: structure with error functions
2. standardizing interface
   1. standard interface for different functionalities
   2. eg: interface to probability distribution in a class, there are many different distributions each has its own class with a common structure/interface
3. grouping multiple returns
4. save internal state for multiple uses
   1. a class that defines a type for a specific solution method
   2. eg: a class for solving a linear system with LU decomposition. the class will store the system matrix and provide methods for solving, investing and computing the determinant
*** Containers
A class that holds objects.

The standard library provides the container vector for instance.

** Classes and members

Members are parts used to define a class.
The member-access notation uses the =.=.


#+begin_src C++
#include <iostream>
using namespace std;

class Myclass {
public:
  int m;		// data member
  int method(int arg) {int old = m; m = arg; return old; } // function member
}

int main () {
  Myclass var;			// creates a variable type Myclass
  var.m = 6;			// ASSIGN value 6 to member
  int x = var.method(10);	// CALL function with argument 10
  cout << var.m << endl;	// changed member from 6 to 10
}
#+end_src

#+RESULTS:
: 10

** Interface and implementation
A class has an interface and an implementation.

The interface is the part of the class declaration that users access directly.

The implementation is the part accessed indirectly by the users through the interface.

The public interface is defined with the label =public=, whereas the implementation with label =private=.
Class members are private by default.


** Structures

Organize elements that a new type needs into a data structure.
It is a _class_ that *only* have *public* members.

#+begin_src C++
#include <iostream>
using namespace std;

struct Vector {			// defines a type: Vector
  int sz;			// type element sz
  double* elem;			// elem is a pointer
}

void vector_init(Vector&v, int s){ // & v is passed by non-const reference
  v.elem = new double[s];	// new creates objects independent on the scope
  v.sz = s;			// v's sz MEMBER gets the int value s
}

double sum_squared(int s)
// sum the square of s first integers
{
  Vector v;			// creates a Vector variable
  vector_init(v, s);		// allocate s elements for f
  for (int i=0; i!=s; ++i)
    v.elem[i] = i*i;

  double sum = 0;
  for (int i=0; i!=s; ++i)
{
    sum += v.elem[i];
    cout << "i " << i << " " << sum << "\n";
}
    return sum;
}

int main ()
{
  cout <<  sum_squared(3);
}
#+end_src

#+RESULTS:
| i | 0 | 0 |
| i | 1 | 1 |
| i | 2 | 5 |
| 5 |   |   |

** Constructor

Member function with _same name_ as its class is known as _constructor_.
It is used to initialize an object of the class.
It is a function that runs when an instance (object) of the class is created.

During the call of the constructor the memory resources for a class are acquired.

The constructor arguments are the ones required to initialize an object.
Initialization occurs when a class is called with the constructor arguments been passed within ={}=.
Is the same as instantiating an object.

The constructor has no return type.

#+begin_src C++
#include <iostream>
using namespace std;

class Date {
public:				// accessible outside
  Date(int yy, int mm, int dd)
  {
    year = yy;
    month = mm;
    day = dd;
    }	// constructor, initialize the class when the class is called with correct arguments
  int year;
  int month;
  int day;
}
int main () {
  Date today {1999, 12, 5};	// creates an object type Date, use {} to INITIALIZE (modern style)
  cout << today.month;
}
#+end_src

#+RESULTS:
: 12

** Functors

Functors are function objects.
Use case: when you need to pass a function and its arguments as an argument to another routine.

In a functor, the object operator =()= has been overload to act as a function call return value.

#+begin_src C++
#include <iostream>

struct Square {
  double operator()(const double x){ // redefine operator () to return
    return x*x;
  }
};

void print_square (auto f, double x) {	// function argument is a function type Square
  std::cout << f(x);		// function can be called here with ()
}

int main () {
  Square g;			// instantiate g as a object with () returning the square
  print_square(g, 2.91);	// passing the functor
}
#+end_src

#+RESULTS:
: 8.4681

** Constant arguments in methods

C++ class methods have implicit =this= parameter which comes before all explicit ones.
The =const= operator after the function arguments make the =this= parameter constant.
The method itself becomes "constant" meaning that it can only be used for member functions.

The =const= in the argument list just means that the argument is immutable within the function scope.


#+begin_src C++
#include <iostream>
#include <ostream>

double square_1 (const double value) {
  return value * value;
}

class math {
public:
  double square_2(double value) const { // different position
    return value * value;
  }
  double var = 10;
      
};

int main() {
  std::cout << square_1(10) << std::endl;
  math mymath;
  std::cout << mymath.square_2(10) << std::endl;
  mymath.var = mymath.square_2(1);
}
#+end_src

#+RESULTS:
: 100
: 100




** Defining member function outside the class

We can do that by using =class_name::member_name=.
Good to avoid long class declarations.

** Member initializer list

To initialize member variables in a list format.
The notation =:year{y}, month{m}, day{d}= more directly express _intent_  of just initialize class members.

#+begin_src C++
#include <iostream>
using namespace std;

class Date {
public:				// accessible outside
  int year, month, day;
  Date(int y, int m, int d);	// just DECLARING the constructor
};

Date::Date(int y, int m, int d) // define the constructor
  :year{y}, month{m}, day{d} {}	// initialize member variables with passed arguments

int main () {
  Date today {1999, 12, 20};	// create an object
  cout << today.day;
}
#+end_src

#+RESULTS:
: 20

Alternative to

#+begin_src C++
#include <iostream>
using namespace std;

class Date {
public: // accessible outside
  int year, month, day;
  Date(int y, int m, int d); // just DECLARING the constructor
};

Date::Date(int y, int m, int d) { // DEFINE the constructor for the class Date
  year = y; // assign the arguments from the class call into the class members
  month = m;
  day = d;
};
int main() {
  Date today{1999, 12, 20}; // create an object
  cout << today.day << endl;
}
#+end_src

#+RESULTS:
: 20


** Initialize members modern

Initialize with the arguments =y,m and d= and directly assign them to the class member data =year, month, day=.

#+begin_src C++
#include <iostream>

class Date {
public:
  int year, month, day;
  Date (int y, int m, int d) : year(y), month(m), day(d) {}
};

int main () {
  Date today(1999, 12, 31);
  std::cout << today.day;
}
#+end_src

#+RESULTS:
: 31

** Operator overloading

Use it when we want to provide conventional notation for a type.
Notation for "increment" =++= or "output" =<<=
Usually not recommended, except when it makes a clear positive impact.

** Symbolic constants within classes

Use the =static= to make sure there is only one copy of the value in the program, rather than one per object of the class.

** Class interface principles

1. complete and minimal
2. provide constructors
3. support copying
4. provide argument checking
5. identify nonmodifying member functions

** Enumerators

Other kind of user defined type (UDT), analogous to classes.
Useful when we need a _set of related named integer constants_.
Can be used to restrict the argument of a function or class, requiring it to be a specific type.

#+begin_src C++
#include <iostream>
using namespace std;

enum Month {
  jan=1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
}

int main () {
  Month m = feb;		// feb in Month scope
  cout << m << "\n";
  // Month m2 = 2;			// not ok.
  cout << Month(5);		// convert int to month
}
#+end_src

#+RESULTS:
| 2 |
| 5 |

** Inheritance
*** Definitionss
1. derived class has _all method and stored states_ of its base class.
2. "is-a" relationship between classes.
3. a parent class may have interface for all method that any child class may benefit from.
4. use inheritance to pass to an object a set of methods with no particular relationship ("grab-bag" analogy) 
** Typedef
*** Definitions
**** What is a =typedef=?
Allows users to create new names for types.
This can be used to give more specific names for built-in types, which improves clarity of the code.
**** Why types are useful?
Guarantee that a variable is used the way it was supposed to.
* Vectors
** Prologue
Vectors are the most useful in the standard library (STL) _container_.
It provides a sequence of elements of a _given type_.

Create a vector container from scratch is useful to understand concepts and C++ facilities such as template and exception.

Memory management low level knowledge is the base for more complex high level ones, like data structures, algorithms and operating systems.

# Why do we need data structures with varying number of elements?
# To represent a vector.

** Fixed size vector

Vector object with only 2 elements.

Problem:
1. hard coded number of elements, no way to add another other elements

#+begin_src C++
class vector {
  int size, elem_0, elem_1; // 2 elements
};

int main (){
  vector myvector; // create an instance of the vector class
}
#+end_src

#+RESULTS:

** Variable number of elements

1. initialize vector class with vector size =s.=
2. during initialization create an array with this size.
   1. when initializing the class data =elem= with =new= allocate memory for an array of double size =s=.
   2. I put the =elem= declaration in the =public= scope so we can print from =main=.
3. assign 0 to array elements.

Problems:
1. vector leaks memory.
   1. creating a vector with =vector myvector(5)= allocates memory.
   2. we need to free the memory using delete after using the vector created, otherwise the memory will be unusable.
2. need to assign each element value individually which is _repetitive and error prone_.
      
#+begin_src C++
#include <iostream>
#include <ostream>

class vector {
  int sz;
public:
  double *elem; // crete a pointer to elements (public so we can access from main)
  vector(int s)
      : sz{s},                // constructor and initialize the member data
        elem{new double[s]} { // new returns a pointer to the first element in
                              // the array size s
    for (int i = 0; i < s; i++)
      elem[i] = 0; // assign 0 to all elements in array size s
  }
  int size() const { return sz; } // return vector size
};

int main (){
  vector myvector{5}; // instantiate with the constructor paramenters
  std::cout << myvector.size() << std::endl;
  for (int i = 0; i < myvector.size(); i++)
    std::cout << myvector.elem[i] << std::endl; // print elements
}
#+end_src

#+RESULTS:
: 5
: 0
: 0
: 0
: 0
: 0

** Avoiding memory leak

The =new= operator gets memory from the /free store/.
It is good practice to return this memory after using it.

When a C++ program starts, the compiler sets aside /code storage/, or /text storage/, memory and //static storage// for the globally defined variables.
It also sets aside memory for call functions, /stack storage/ or /automatic storage/. 
The /free store/, or /heap/, is what is left to the system.
When =new= operator is called it makes this /free store/ available to the program, memory leaks.

Each vector creation "leaks" the =s= doubles allocated to the newly created vector.
Meaning that it leaked from the free store memory available in the system.
We can free the memory up by =delete[] myvector;= after using.

Just deleting is not a good practice because it is not robust or reliable enough.

** Destructor

The /destructor/ is represented by calling the same constructor function with =~= in the front.
The constructor is called implicitly when an object class is created, instantiated, the *destructor is called also implicitly when the object goes out of scope*.

When do we need a destructor? when a class acquires resources and must give it back once finished using it.
A vector class, for instance, acquires memory to store the vector elements.
Generally, if a class has pointer members or references it will need a destructor.

When the destructor is called the elements _pointed to_ by the vector =elem= pointer will be deleted, /freed/.

The standard library =vector= does that already.

#+begin_src C++
#include <iostream>
#include <ostream>

class vector {
  int sz;
public:
  double *elem; // crete a pointer to elements (public so we can access from main)
  vector(int s)
      : sz{s}, // constructor and initialize the member data
        elem{new double[s]} {	// new returns a pointer to the first element in the array size s 
   for(int i=0; i<s; i++) elem[i] = 0; // assign 0 to all elements in array size s
  }

  int size() const { return sz; } // return vector size

  ~vector() {			// destructor
   delete[] elem; 		// free memmory
  }
};

int main (){
  vector myvector{5}; // instantiate with the constructor paramenters
  std::cout << myvector.size() << std::endl;
  for(int i=0; i<myvector.size(); i++) std::cout << myvector.elem[i] << std::endl; // print elements
}
#+end_src

#+RESULTS:
: 5
: 0
: 0
: 0
: 0
: 0

** =get()= and =set()= methods

#+begin_src C++
#include <iostream>
#include <ostream>

class vector {
  int sz;
public:
  double *elem;
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  int size() { return sz; }
  ~vector() { delete[] elem; }
  double get(int n) { return elem[n]; }
  void set(int n, double v) { elem[n] = v; }
};

int main() {
  vector myvector{5}; // instantiate with the constructor paramenters
  std::cout << myvector.size() << std::endl;
  for (int i = 0; i < myvector.size(); i++)
    std::cout << myvector.elem[i] << std::endl; // print elements
  myvector.set(3, 19);
  std::cout << myvector.get(3) << std::endl;
}
#+end_src

#+RESULTS:
: 5
: 0
: 0
: 0
: 0
: 0
: 19


** Getting element's values

We can use the =get()= method or the arrow =->= operator.

All classes support the =->= operator to access a member via a pointer.
It can be used for data member and function members.
The =->= arrow is _analogous_ to =.= dot access but for pointers instead of variables.

#+begin_src C++
#include <iostream>
#include <ostream>

class vector {
  int sz;

public:
  double *elem;
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  int size() { return sz; }
  ~vector() { delete[] elem; }
  double get(int n) { return elem[n]; }
  void set(int n, double v) { elem[n] = v; }
};

int main() {
  vector myvector{5};
  myvector.set(3, 19);
  std::cout << myvector.get(3) << std::endl;	// using get()

  vector* p = new vector(4);		// p is a pointer to a vector created with new
  double d = p->get(3);		// -> access the member function get() with the pointer
  std::cout << d;
}
#+end_src

#+RESULTS:
: 19
: 0

** Constructor with initializer list ={}=

Instead of assigning value to each element individually we can pass an _initilizer list_ to the constructor with the element values.
The ={}= delimited list of a specific type is an object of the standard library =initialize_list<T>=.


#+begin_src C++
#include <algorithm>
#include <initializer_list>
#include <iostream>
#include <ostream>

class vector {
  int sz;
  double *elem;
public:
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }

  vector(std::initializer_list<double> lst)
      : sz(lst.size()), elem{new double[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  
  void print_vec() {
    for (int i = 0; i < sz; i++) {std::cout << elem[i] << ", ";}
    std::cout << std::endl;
  }
};

int main() {
  vector vec1(5);		// () for element count
  vec1.print_vec();
  vector vec2{5, 2, 3};		// {} for element lists
  vec2.print_vec();
  vector vec3 = {11, 17, 19};	// using = is a clear way to pass the element list
  vec3.print_vec();
}
#+end_src

#+RESULTS:
: 0, 0, 0, 0, 0, 
: 5, 2, 3, 
: 11, 17, 19, 

Remarks:
1. using standard library =initialize_list<T>= class to initialize a list of elements type =T= by passing it as argument to the constructor.
2. notice the initialization of =sz(lst.size())= uses =()= instead of ={}=
   1. avoids the warning: =clang: Non-constant-expression cannot be narrowed from type 'std::initializer_list::size_type' (aka 'unsigned long') to 'int' in initializer list (fix available)=
3. the class has now two constructor options, one with the number of elements and the other with the elements values.
4. =new= is used to allocate memory space not yet initialized, which is done in the next line
5. standard library =copy()= algorithm copies sequence specified by the first two arguments =lst.begin()= and =lst.end()= into the third argument =elem=.  

** Copying
*** Definitionss
 
When do we need a copy constructor?
A class that needs a destructor will most probably need a copy constructor and copy assignment.
*** Standard copying behavior

We are passing the elements of the vector through a pointer =elem=.
When we make a copy, we are copying the pointer.
This means that the copy also points to the same address as the original.


#+begin_src C++
#include <iostream>
#include <ostream>

class vector {
  int sz;

public:
  double *elem;
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  int size() { return sz; }
  // ~vector() { delete[] elem; }
  vector(std::initializer_list<double> lst)
      : sz(lst.size()), elem{new double[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  void print_vec() {
    for (int i = 0; i < sz; i++) {std::cout << elem[i] << ", ";}
    std::cout << std::endl;
  }
};

int main() {
  vector vec1 = {1, 2, 3};
  vec1.print_vec();
  vector vec2 = vec1;			// make a copy
  vec1.elem[0] = 99;				// change first entry of VECTOR 1
  vec2.print_vec(); 
}
#+end_src

#+RESULTS:
: 1, 2, 3, 
: 99, 2, 3, 

This gives the error: =free(): double free detected in tcache 2= If we leave the destructor.
This error happens because the destructor for =vec1= is called then its elements are deleted to free up the memory.
However de destructor for =vec2= is also called and this time it does not encounter anything left to delete.

If the destructor is commented out, it can run.
We observe that by changing =vec1= e also changed the elements of =vec2=, because they point to the same address.
*** Copy constructor

Initialization of class objects is always done by a constructor.
We call _copy constructor_ the one that take as argument _a reference to the object from which to copy_, =vector(const vector&)=.

The operator =&= is same used to create a reference object.
The =const= indicates that we don't want to change the reference (object that we are copying, the original).

When we instantiate an object of the class by passing another object of the same class the /copy constructor/ is called.


#+begin_src C++
#include <algorithm>
#include <iostream>
#include <ostream>

class vector {
  int sz;
public:
  double *elem;
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  int size() { return sz; }
  ~vector() { delete[] elem; }
  vector(std::initializer_list<double> lst)
      : sz(lst.size()), elem{new double[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  void print_vec() {
    for (int i = 0; i < sz; i++) {std::cout << elem[i] << ", ";}
    std::cout << std::endl;
  }

  vector(const vector& arg) 		// COPY CONSTRUCTOR
  : sz(arg.sz), elem{new double[arg.sz]} // allocates memory for the elements
  {
  std::copy(&arg.elem[0], &arg.elem[sz], elem); // arg.elem is a pointer to the first address of the vector
  }
};

int main() {
  vector vec1 = {1, 2, 3, 12, 12};
  vec1.print_vec();
  vector vec2 = vec1;			// make a copy
  vec1.elem[0] = 99;				// change first entry of VECTOR 1
  std::cout << "changed original!" << std::endl;
  vec2.print_vec(); 
  vec1.print_vec();
}
#+end_src

#+RESULTS:
: 1, 2, 3, 12, 12, 
: changed original!
: 1, 2, 3, 12, 12, 
: 99, 2, 3, 12, 12, 

Remarks:
1. As expected now we have each vector in a separate memory slot.
2. =&arg.elem[sz]= returns the address of the last element of =arg.elem=, because the member data =elem= is a pointer.
3. changing the original vector does not affect the copy


*** Copy assignments constructor
# 18.3.2 Stroustrup

In the copy assignment we want to control the behavior of a simple assignment =vec1=vec2=.
This is done with another constructor =vector& operator=(const vector& rhs)=.
This constructor is called when an object of the class appears on the left side of an assignment expression.

Default meaning of "copy assignment" is memberwise copy.
Without the proper handle of the assignment operation we are going to have 2 pointers pointing to the same memory location.
Assignment will cause a double deletion and memory leak.

#+begin_src C++
#include <iostream>

class vector {
  int sz;
public:
  double *elem;
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  int size() { return sz; }
  ~vector() { delete[] elem; }
  vector(std::initializer_list<double> lst)
      : sz(lst.size()), elem{new double[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  void print_vec(int vec_id) {
    std::cout << "vector " << vec_id << " = [";
    for (int i = 0; i < sz; i++) {
      std::cout << elem[i] << ", ";
    }
    std::cout << "]" << std::endl;
  }
  vector& operator=(const vector& rhs){ // COPY ASSIGNMENT constructor
    double *p = new double[rhs.sz];     // allocate memory for the copy
    std::copy(&rhs.elem[0], &rhs.elem[sz], p);     // beg, end, destination
    delete[] elem;			// dealocate old
    elem = p;				// new elem
    sz = rhs.sz;
    return *this;		//  return self reference
  }
};

int main() {
  vector vec = {1, 2, 3};
  vec.print_vec(1);
  vector vec_copy(3);
  vec_copy = vec;	// ASSIGNMENT COPY
  vec_copy.print_vec(2);
  vec_copy.elem[0] = 1000;		// change copy
  std::cout << "changed copy!" << std::endl;
  vec.print_vec(1);
  vec_copy.print_vec(2);
}
#+end_src

#+RESULTS:
: vector 1 = [1, 2, 3, ]
: vector 2 = [1, 2, 3, ]
: changed copy!
: vector 1 = [1, 2, 3, ]
: vector 2 = [1000, 2, 3, ]

Remarks:
1. =vector& rhs= means that the function gets a reference
2. =copy(rhs.elem, rhs.elem.sz, p);= which is in the book does not work
   1. gives an error: =request for member ‘sz’ in ‘rhs.vector::elem’, which is of non-class type ‘double* const’=
   2. solved by manually get the memory address of the first and last member
3. =return *this=

*** Shallow and memberwise copy
# 18.3.3

A shallow copy means copying _just the pointer (or reference)_.
Now two pointers point to the same object.

#+begin_src C++
#include <iostream>
#include <ostream>

int main() {
  int *ptr = new int{2};
  int *new_ptr = ptr;		// copy with assignment operator
  ,*ptr = 8;
  std::cout << "old pointer content: " << *ptr << std::endl;
  std::cout << "new pointer content: " << *new_ptr;
}

#+end_src

#+RESULTS:
: old pointer content: 8
: new pointer content: 8

A deep copy on the other hand refers to copying the *content*, what the pointer points to.
Now two pointers refer to two distinct objects.


#+begin_src C++
#include <iostream>
#include <ostream>

int main() {
  int *ptr = new int{22}; 
  int *new_ptr = new int{*ptr}; 	// creates new pointer with same content as ptr
  *ptr = 88;
  std::cout << "old pointer content: " << *ptr << std::endl;
  std::cout << "new pointer content: " << *new_ptr;
}

#+end_src

#+RESULTS:
: old pointer content: 88
: new pointer content: 22

** Move constructor
# 18.3.4
*** Definitions
When to use a move constructor?
A class that needs a destructor will probably need a move constructor and move assignment.
If a vector has a lot of elements copying it is expensive.
*** Move constructor and assignment

The move constructor uses the "rvalue reference" =&&=, =vector(vector&& a);=.
This operator is used to _define move operations._

The operator will modify the source, therefore the argument of the constructor is not constant.
The modification is to make the source empty.

The advantage of moving instead of copying is to move around information cheaply.

#+begin_src C++
#include <iostream>

class vector {
  int sz;
public:
  double *elem;
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  int size() { return sz; }
  ~vector() { delete[] elem; }
  vector(std::initializer_list<double> lst)
      : sz(lst.size()), elem{new double[sz]} {
    std::copy(lst.begin(), lst.end(), elem);
  }
  void print_vec(int vec_id) {
    std::cout << "vector " << vec_id << " = [";
    for (int i = 0; i < sz; i++) {
      std::cout << elem[i] << ", ";
    }
    std::cout << "]" << std::endl;
  }
  // move constructor
  vector(vector&& a)
  : sz{a.sz}, elem{a.elem} {	// copy a and elem
    a.sz = 0;			// modify source (a, rvalue)
    a.elem = nullptr;		// EMPTY VECTOR!
  }
  // move assignment
  vector &operator=(vector&& a){
  delete[] elem;		// dealocate OLD SPCAE
  elem = a.elem;		// COPY from rvalue return
  sz = a.sz;
  a.elem = nullptr;		// delete rvalue return from memory
  a.sz = 0;
  return *this;			// SELFR REFERENCE
  }
};

vector use(double value) {
  vector res(10);
  res.elem[0] = value;
  return res;
}

int main() {
  vector vec = use(99);		// get the return and copy into vec
  vec.print_vec(1);
  vector vec2(2);		// orignal has 2 elements
  vec2 = use(11);			// move assignment
  vec2.print_vec(2);
}
#+end_src

#+RESULTS:
: vector 1 = [99, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
: vector 2 = [11, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]

Remarks:
1. move operator does not take =const= arguments.
2. move construct is implicitly used when =return= is called.
   1. instead of copying the return to =vec=, we just move it.
3. the function call =use()= is an "rvalue".
   1. when a "rvalue"is passed to the constructor it gets its reference.
4. the move constructor copies the paramenters from the rvalue return and delete it.
5. the move assignment first deletes the original space,
   1. then it copies the rvalue elements and size;
   2. deletes the rvalue after it was copied;
   3. returns a self reference;
*** Move constructor importance
We use it so we don't have to deal with pointers or references to get large amount of information from a function.

Without them, we would have to:
1. create a vector in the function call and return it as a pointer;
2. use the vector and then delete it; (not ideal, better handle object creation automatically)

** TODO Default constructor
Used when we want to make an object instance without specifying an initializer, =vector{}=.

Useful when we want to pass an object of a class into a standard library vector, for instance =vector <vector<int>> vec(10);= means vector of vector.

#+begin_src C++
#include <iostream>

template <typename T> class vector {
  int sz;
  T *elem; // pointer to elements
int space; // size+free space
public:
vector() : sz{0}, elem{nullptr}, space{0} {} // default constructor
};

int main () {
vector<int> vec_default;		// default init
}
#+end_src
** TODO Explicit constructor
The speficier =explicit= for constructor specify that the constructor can only be invoked with ={}= or =()=.
It does not accept === which is better to use only for assignments.

#+begin_src C++
#include <iostream>

template <typename T> class vector {
  int sz;
  T *elem; // pointer to elements
int space; // size+free space
public:
explicit vector(int s) : sz{s}, elem{new T[s]}, space{s} {
  for (int i = 0; i < sz; ++i)
    elem[i] = 0;		// construct with just size, elements 0
}
};

int main () {
vector<double> vec_withsize(4);		// initializing with size
}
#+end_src
** Access to vector elements
# 18.5
*** Motivation

Alternative to "verbose" syntax of =get()= and =set()=.
Use the math subscript notation: =v[i].=
*** Member function =operator[]=

Just defining a member function and return the element value referent to the index allows an equivalent to =get()=.
But it does not allows changing the element by using an assignment.

#+begin_src C++
#include <iostream>
class vector {
  int sz;
  double *elem;
public:
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  void print_vec(int vec_id) {
    std::cout << "vector " << vec_id << " = [";
    for (int i = 0; i < sz; i++) {
      std::cout << elem[i] << ", ";
    }
    std::cout << "]" << std::endl;
  }
  double operator[](int n) { return elem[n]; }
};

int main() {
  vector v{10};
  v.print_vec(1);
  std::cout<< v[0]; 
  // v[0] = 9;// ERROR! lvalue required as left operand of assignment
}
#+end_src

#+RESULTS:
*** Return pointer to elements

To return pointer we use the dereference operator =*= in the function return type so it returns a pointer.
In the return statement we use the "address of" operator to get the address of the member.

When we call =v[i]= we are in fact calling the member function =v.operator[]()=. 

#+begin_src C++
#include <iostream>
#include <ostream>

class vector {
  int sz;
  double* elem;
public:
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  void print_vec(int vec_id) {
    std::cout << "vector " << vec_id << " = [";
    for (int i = 0; i < sz; i++) {
      std::cout << elem[i] << ", ";
    }
    std::cout << "]" << std::endl;
  }
  double* operator[](int n) { return &elem[n]; }
};

int main() {
  vector v{10};
  v.print_vec(1);
  std::cout<< v[0] << std::endl;// pointer address
  std::cout<< *v[0] << std::endl;// * gets the content of the pointer
  // v[0] = 1;	// error! v[0] returns a pointer to element 0
  *v[0] = 1; 	// we need to use the dereference to change the element value
  v.print_vec(2);
}
#+end_src

#+RESULTS:
: vector 1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
: 0x5578e704aeb0
: 0
: vector 2 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]

Remarks:
1. 

*** Return a reference to elements
Now, instead of returning a pointer we return a reference with =double&=.
With a reference we can change the element value without the need to use the dereference =*= operator to get the pointer value.

This is the conventional implementation.

#+begin_src C++
#include <iostream>
class vector {
  int sz;
  double* elem;
public:
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  void print_vec(int vec_id) {
    std::cout << "vector " << vec_id << " = [";
    for (int i = 0; i < sz; i++) {
      std::cout << elem[i] << ", ";
    }
    std::cout << "]" << std::endl;
  }
  double& operator[](int n) {
    return elem[n]; // returns reference
  }
};

int main() {
  vector v{10};
  v.print_vec(1);
  v[0] = 1; // we can change the value of the reference
  v.print_vec(2);
}
#+end_src

#+RESULTS:
: vector 1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]
: vector 2 = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, ]

Remarks:
1. when we call the subscript operator =[]= we could potentially change the vector.
   1. solution is to make this member function =const=
*** =const= member function

Used so when we try to change a constant vector it blocks the operation.
The syntax is to add =const= after the function parameters =double operator[](int n) const;=.

Vectors are often passed as constant objects, so the =operator[]() const= is an essential part.

#+begin_src C++
#include <iostream>
class vector {
  int sz;
  double* elem;
public:
  vector(int s) : sz{s}, elem{new double[s]} {
    for (int i = 0; i < s; i++)
      elem[i] = 0;
  }
  void print_vec(int vec_id) {
    std::cout << "vector " << vec_id << " = [";
    for (int i = 0; i < sz; i++) {
      std::cout << elem[i] << ", ";
    }
    std::cout << "]" << std::endl;
  }
  void print_vec(int vec_id) const {
    std::cout << "vector " << vec_id << " = [";
    for (int i = 0; i < sz; i++) {
      std::cout << elem[i] << ", ";
    }
    std::cout << "]" << std::endl;
  }
  double& operator[](int n) {
    return elem[n]; // returns reference
  }
  double operator[](int n) const {
    return elem[n]; // returns reference
  }
};

int main() {
  vector v{10};
  v[0] = 1; // regular operator[]
  v.print_vec(2);

  const vector v2{5}; // constant vector
  // v2[0] = 9;	      // error! lvalue required as left operand of assignment
  v2.print_vec(3);
  // v2[0] = 1; // error! lvalue required as left operand of assignment
}
#+end_src

#+RESULTS:


Remarks:
1. when a =const vector= is passed to the non const =operator[]=
   1. we get an error because the lvalue is =const= in a function that is not
   2. the function could potentially change the =const= value
2. when after introducing a =operator[] const=
   1. we try to change the =const= vector with the subscript operator we get an error
   2. the =operator[] const= _does not return a reference_ =double&= it returns a regular =double= _value_!
   3. can be used just to print the =const= vector elements
   4. could instead return =const double&= reference!
      1. _no point in returning a reference for a small object!_
3. to print the =const= vector a =print_vec() const= was required!
** Arrays
# 18.6
*** Definition
Sequence of objects allocated on free storage.
Homogeneous and allocated in a contiguous form.

Prefer vectors instead of arrays.
Because:
1. arrays don't know their own size
   1. keeping track of array bounds at compile time is impossible
2. member arrays are hard to initialize
** Vector conclusion

The vector class can:
1. create vectors (objects of the class) of double elements
2. create vectors with any number of elements
3. copy vectors using assignment and initialization
4. release memory reliably after going out of scope
5. access vector using conventional subscript notations on right-hand side and left-hand side of assignment

** Problems still to be solved
# 1.4 - (). Numerical Recipes. : .
# 1. it can not return an element by its subscript.

1. how to change the size of the vector?
2. how catch and report out-of-range vector element access?
3. how to specify the _element type_ of a vector _as an argument_?

* Templates
** Definitions
*** What is a template?

_A template is mechanisms that allows to /use types as parameters/ for a class of function._
The compiler generates a specific class or function when we provide a specific type as argument.

Instead of creating a vector with =double= elements, what if we want =Date= elements of a specific user-defined type?
*** What is a container?

Containers are entities that store data.

There are many kinds of containers.
For instance, =vector=, =string=, =list= and etc. 

At the memory level all objects are fixed in size and there are no types.
Containers with types and flexible size are provided by a programming language facility.
This allows flexibility and convenience.
*** What is template instantiation?
The process of generating a class from a class template.
Also known as specialization.
This process is done by the compiler.
*** What is generic programming?
Code that works with a variety of types.
The template feature allows generic programming.
*** What is parametric polymorphism?
Form of generic programming that relies on explicit template parameters.

Different from polymorphism from object-oriented programming.
*** Why put template definition in header files?

The compiler requires that a template must be fully defined wherever it is used, all member functions and all template functions.
*** What is a concept?

A set of requirements on a template argument.

For instance, a vector requires that its elements can be copied, moved and so on.

A concept is a type predicate, which means a compile-time-evaluated function that return =true= if type argument has the properties required by the concept.

Example for C++14 or more:

#+begin_src C++
template<class T>
requires Element<T>()		// such that T is an Element
class vector {};
#+end_src

which is equivalent todo

#+begin_src C++
template<Element T>
class vector {};
#+end_src

** TODO Changing size
# 19.2
** Creating Templates

We use the directive =template<typename T>= before our class creation to get a type as parameter when instantiating the class.
One can also use =template<class T>, which seems clearer=.
The =T= is specific type passed in =vector<TYPE>= when creating an objects.

#+begin_src C++
#include <iostream>

template <class T> class vector {
  int sz;
  T *elem; // pointer to elements
  int space; // size+free space
public:
  vector() : sz{0}, elem{nullptr}, space{0} {} // default constructor
};

int main () {
  vector<int> vec_int;		// default init
  vector<double> vec_double;
  vector<vector<double>> vec_of_vec_double; // each element is a vector of double
}
#+end_src
        
    
#+RESULTS:

** Type as template parameters
Goal is to make the element type a parameter to a vector class.

#+begin_src C++
#include <iostream>

class Vector {
int size;
int space;
public:
Vector(): size{0}, space{0} {};		// constructor
};

int main() {
Vector myvec;			// instantiate class

}
#+end_src

#+RESULTS:

** Passing function or functor as arguments

A templated function allows the compiler to know if =func= is a function or a functor.

#+begin_src C++
#include <iostream>

template <class T> double Quadrature(T &func, double a) { return func(a); };

double f(double x) { return x * x; }; // defining a function

int main() { std::cout << Quadrature(f, 2); } // passing a function as argument
#+end_src

#+RESULTS:
: 4

* Numerics
# 24
** Accumulate
As an introduction to the numerical library.

The function takes
1. first element of the sequence
2. last element of the sequence
3. initial value (accumulator variable)

#+begin_src C++
#include <iostream>
#include <numeric>

int main () {
int a[] = {1, 2, 3, 4};
std::cout << sizeof(a) << std::endl;
std::cout << sizeof(int) << std::endl;
std::cout << std::accumulate(a, a+sizeof(a)/sizeof(int), 0);
}
#+end_src

#+RESULTS:
: 16
: 4
: 12

Remarks:
1. the end of the sequence was defined with the size function of the whole sequence (16) which represents 4 integers (4);

* Libraries
** Standard library
Libraries that provide some useful tools (data structures and algorithms) for every programmer.
** Headers and namespace
A header argument provides a standard library facility.
Standard library is defined in a namespace =std=, which is a prefix that access the facilities.
The prefix can be avoided with =using namespace std;=.

#+begin_src C++
#include<string>

int main() { std::string s{"a string"}; }
#+end_src


#+RESULTS:
** External libraries

With an external library source code in a specific folder.

We need:
1. compile our code including the path of the library that we downloaded
   1. compiler must know where the library header files are (=.h=)
2. linker must know where the libraries are (for static or dynamic linking)
   1. linker must know where the "implementation" of the things "declared" in the header files
   2. libsynaptics
   3. 


**** General definitions
A library is just code with _declarations_ with statements of how to use the functions and classes.

1. static libraries are represented with =.lib= or =.a=
2. dynamic libraries with =.dll= or =.so=

**** Including a library in =/usr/include/=
C++ compiler founds automatically external libraries in the folder =/usr/include/=.

#+begin_src C++
#include <library_name/headerfile.h>
#+end_src

**** Including a library elsewhere

Need to find the path to the library header file.

** Static and dynamic libraries

Static libraries (also known as "archive") are linked to the programs at _compile time_.
The executable has a copy of library code, makes it bloated.
If we modify the library we need to recompile and link again the other parts of the application that depend on this library.


On the other hand, dynamic or shared libraries have code that is meant to be used by multiple programs.
The content is loaded to the memory at _runtime_ and only once.
Loading a library dynamic is more efficient way to use memory when there are more than one executable running and depending on the dynamic library content.
One hurdle is a more intricate installation process regarding proper placement of the library.


Reference: [[https://domiyanyue.medium.com/c-development-tutorial-4-static-and-dynamic-libraries-7b537656163e][C++ Development Tutorial 4: Static and Dynamic Libraries | by Domi Yan | Medium]]

** Using dynamic libraries

Dynamic libraries can be used by compiling your program together with the shared library file.

Let's say we have this header file called =mymath.h= with a declaration of a function

#+begin_src C++ :tangle "mymath.h" :main no
double reciprocal (double x);
#+end_src

#+RESULTS:

and its implementation/definition in =mymath.cpp=

#+begin_src C++ :tangle mymath.cpp :main no
#include "mymath.h"

double reciprocal (double x) { return 1. / x; }
#+end_src

#+RESULTS:

We want to use this "library" in our program.
We just want to use the function =reciprocal= without having to worry about compilations details of this library.
Then, we build the shared library with

#+begin_src shell 
clang++ -shared -o libmath.so mymath.cpp
ls
#+end_src

#+RESULTS:
| libmath.so |
| main.cpp   |
| mymath.cpp |
| mymath.h   |

Now we have the library we want to use compiled as a shared library =libmath.so=.
In our code we then include the declaration of the function with the head =math.h=, and use the function.

#+begin_src C++ :tangle main.cpp
#include <iostream>
#include "mymath.h"

int main() {
std::cout << reciprocal(2.); 
}
#+end_src

#+RESULTS:

When we compile our code, we use the commands bellow.
Notice that we manually have to pass the library path to the linker with =-rpath= flag.
The flag =-Wl= is used to pass a list of arguments to the linker.

#+begin_src shell
clang++ main.cpp libmath.so -Wl,-rpath,/mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes
./a.out
#+end_src

#+RESULTS:
: 0.5

It seems that CMake builds the executable with the RPATH for the build tree (https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling).


** Dynamic libraries and linking

A dynamic library can be replaced without re-linking.

* Features overview
** C++ 20
*** Range-based for loops with initializer

Loops through an object elements.

#+begin_src C++
#include <iostream>
#include <vector>

int main () {
for (std::vector<int> v{1, 2, 3}; auto& e : v) {
  std::cout << e;
 }
}
#+end_src

#+RESULTS:
: 123

* Effective and modern
** Template type deduction
Frees you from typing obvious or redundant types.

Appears in calls to function templates and when auto is used. 

** TODO =auto= type deduction (2 Meyers)
*** Why prefer =auto= to explicit type declarations?
** Smart pointers
*** What is it smart about it?

** Universal references (&&)

*** What is an universal reference?
It is a term to describe the concept of: taking an =rvalue= reference to a cv-unqualified template, which can be deduced as a =rvalue= or =lvalue=.

#+begin_src C++
#include <iostream>

class Widget {
public:
Widget(Widget&& rhs);		// an argument to this constructor will bind to an rvalue reference
};

int main() {
int a = 1;			// a is an lvalue 
Widget myobject(a);
}
#+end_src


** Modern practices
*** TODO Why choose =()= instead ={}= when creating objects matter? (7 Mayers)
**** Possible initialization operators
Object initilization:
1. =int x(0);= with parenthesis
2. =int x=0;= with equal sign
3. =int x{0};= with braces
4. =int x = {0};= with equal sign and braces
   

**** Problems with == {};= 
1. Usage of equal sign is confused with object /assignment/ (calls to =copy operator==).

Braced initialization is an /uniform initialization/ that can be used anywhere.
There are situations where initilization with =()= and === does not work, for instance default value of private class members and uncopyable objects respectively.

**** Narrowing conversion
Braced ={}= initialization prohibits _implicit narrowing conversions_ among built-in types.
If the type of the expression in the brace in not guaranteed to be expressible by the /type of the object been initialized/, it gives an error.

Initilization with  === Meyers says it works.

From this experience with /clang/ compiler, it seems that both can be done and the double is converted to int automatically.
The compiler just gives a warning: =clang: Type 'double' cannot be narrowed to 'int' in initializer list (fix available)=.

#+begin_src C++
#include <iostream>

int main() {
int x {2};		
double y {1.99};
int sum{x + y}; // clang: Type 'double' cannot be narrowed to 'int' in
// initializer list (fix available)
std::cout << sum;
int sum2 = x + y;		// clang also gives an  
}
#+end_src

#+RESULTS:
: 3

**** Problems with ={}= braced initialization

If the class has a constructor, /ctor/, that has an =std::initilize_list= as argument it seems that the compiler "strongly prefer" overloads taking this list initialization constructor.

*** What are scoped =enums=?

*** What are special function generation?

*** Pass by value or pass by reference?

** Abstract base class (ABC) or Template
# Numerical recipes 1.5.3
When a function is intended to process on multiple object types.
We can have an abstract class and multiple derived ones or a function with a template.

The template must be available to the compiler every time it encounter a call to the function.
The compiler in fact needs to compile a different version of the templated function each time it encounter a different type.

In the case of the template solution, the consistency will be enforced when the templated function is actually called with an specific argument type.
Not when the object type is defined.
This can be hard to debug in some cases.

* Configuring and compiling
*** Compilation

The _compiler_ translates the source code from human language to machine language (executable or object code).
The compilation process occurs for one "translation unit" at a time.

When the compiler is called on a file, it will read the file and if it finds the =#include= it will read the file that is include and compile it as well.
# unnecessary #include can increases compilation time
*** Linking

All parts of the program must be compiled and the resulted _object code files =.obj= must be linked_ to form an executable program.
The linker is responsible for linking.

Object code and executable *are not portable* among different systems.

Whereas the compilation happens for one translation unit at a time, during the linking two translation units are linked together.

*** Makefile

It is a file that manages the compiling of a project (multiple c++ files). 
When you call =make= it uses the =Makefile= instructions.

The management means:
1. specify "targets" and list of dependencies
   1. a target can be a word (a phony) such as "all"and "clear" or a file name
   2. convention is to use the first target "all" will run with simple =make=
2. specify "make actions", e.g. clean or build
3. specify files/objects that make need to build

A sample Makefile would look like

#+begin_example
all: mybinary

mybinary: files.o
commands

files.o: files.cpp files.h
commands
#+end_example
*** Configure
This script is used to set up the building process.
The set up involves making sure that all tools necessary are available in the _specific environment_ where the program is going to be built.
For instance, which compiler is it going to use to translate the source code?

When we call =./configure= it produces =Makefiles= specific for the current system (usually from a template =Makefile.in=).

The =./configure= script examines the system and get appropriate paths.
Usually the =./configure= and =Makefile.in= template are automatically generated with other tools.

*** =make=

The command =make= is responsible to "_build_" the software.
It takes the =./Makefile= and build the first target.
The =Makefile= has _instructions to compile_ (and linking) all the files that we need for our program to work.

*** Make clean

When =make= sees old executables it assumed that nothing needs to be done, so if you changed them you need to do =make clean.=

If in the makefile the dependencies changed, then =make= will rebuild them.

*** Make usage
If we want to compile =main.cpp= (from the example in [[*Using dynamic libraries][Using dynamic libraries]]) for instance, the =Makefile= should have

#+begin_example
default:
clang++ main.cpp mymath.cpp -o output_with_make.out
#+end_example

Then, we can run with

#+begin_src shell :results output
make
./output_with_make.out
#+end_src

#+RESULTS:
: clang++ main.cpp mymath.cpp -o output_with_make.out
: 0.5

References: [[https://makefiletutorial.com/][Makefile Tutorial By Example]]


*** Make install

The command =make install= copies the binaries from the step (with =make=) and put them into appropriate locations to be accessed.

The locations are defined in the =Makefile=.
In the =./condigure= step we can pass specific value so the appropriate locations are set in the =Makefile=.

If the location requires administrative privileges we can use =sudo make install= to accomplish the copying task.

*** Questions
**** What to do after changing the code?
Only when a file changes it needs to be recompiled.
So, in a large project, when a single source file changes, the compilation process should be quick.

**** When we need to call =make= again

When we run =make= it will check if the file with target: "all" is updated.
If it is not newer than its dependencies, it will call the command to _rebuild_ the binary.

**** What is the difference between =g++= and =gcc=?

Both are "compiler-drivers" of the GNU compiler collection.
This collection was only GNU C compiler, now supports multiple languages.

The main difference is their default libraries to link automatically.

=g++= will automatically link to the "STD C++ libraries", =gcc= will not.
The call =gcc -lstdc++= will link to the standard library.

**** When to use =-fPIC= flag?

Positional independent code.
Used when building shares objects (=.so=)
With this flag we tell the OS we are using Global Offset Table, GOT.
All addresses references are relative to the GOT.
And the code can be shares across multiple processes.

**** How to learn about compiler flags?

- Wall :: turn all warnings on.

#+begin_src shell
man g++ | grep -C 3 fPIC 
#+end_src

#+RESULTS:
#+begin_example
           -fasynchronous-unwind-tables -fno-gnu-unique
           -finhibit-size-directive  -fno-common  -fno-ident
           -fpcc-struct-return  -fpic  -fPIC  -fpie  -fPIE  -fno-plt
           -fno-jump-tables -frecord-gcc-switches -freg-struct-return
           -fshort-enums  -fshort-wchar -fverbose-asm  -fpack-struct[=n]
--
           link.  Currently, the following options and their settings are
           taken from the first object file that explicitly specifies them:
           -fPIC, -fpic, -fpie, -fcommon, -fexceptions, -fnon-call-exceptions,
           -fgnu-tm and all the -m target flags.

--

           If type is dyn the code generation is configured to produce shared
           library. In this case -fpic or -fPIC is preserved, but not enabled
           automatically.  This makes it possible to build shared libraries
           without position independent code on architectures this is
--
           to form an executable.  Not all systems support this option.  For
           predictable results, you must also specify the same set of options
           used for compilation (-fpic, -fPIC, or model suboptions) when you
           specify this linker option.[1]

--
           executable exceeds a machine-specific maximum size, you get an
           error message from the linker indicating that -fpic does not work;
           in that case, recompile with -fPIC instead.  (These maximums are 8k
           on the SPARC, 28k on AArch64 and 32k on the m68k and RS/6000.  The
           x86 has no such limit.)
--
           defined to 1.

       -fPIC
           If supported for the target machine, emit position-independent
           code, suitable for dynamic linking and avoiding any limit on the
--
       -fpie
       -fPIE
           These options are similar to -fpic and -fPIC, but the generated
           position-independent code can be only linked into executables.
           Usually these options are used to compile code that will be linked
--
           Do not use jump tables for switch statements even where it would be
           more efficient than other code generation strategies.  This option
           is of use in conjunction with -fpic or -fPIC for building code that
           forms part of a dynamic linker and cannot reference the address of
           a jump table.  On some targets, jump tables do not require a GOT
--
           R_ARM_ABS32).  This is enabled by default on targets (uClinux,
           SymbianOS) where the runtime loader imposes this restriction, and
           when -fpic or -fPIC is specified. This option conflicts with
           -mslow-flash-data.

--
           method.  This allows for execute in place and shared libraries in
           an environment without virtual memory management.  This option
           implies -fPIC.  With a bfin-elf target, this option implies -msim.

       -mno-id-shared-library
--
       -mno-gotplt
       -mgotplt
           With -fpic and -fPIC, don't generate (do generate) instruction
           sequences that load addresses for functions from the PLT part of
           the GOT rather than (traditional on other architectures) calls to
--

           When generating code for shared libraries, -fpic implies
           -msmall-data and -fPIC implies -mlarge-data.

       -msmall-text
--
           implies -fPIE.  With -fpic or -fpie, it assumes GOT entries and
           small data are within a 12-bit range from the GOT base address;
           with -fPIC or -fPIE, GOT offsets are computed with 32 bits.  With a
           bfin-elf target, this option implies -msim.

--
           are not known to bind locally.  It has no effect without -mfdpic.
           It's enabled by default if optimizing for speed and compiling for
           shared libraries (i.e., -fPIC or -fpic), or when an optimization
           option such as -O3 or above is present in the command line.

--
           default, except for -fpic or -fpie: even though it may help make
           the global offset table smaller, it trades 1 instruction for 4.
           With -fPIC or -fPIE, it trades 3 instructions for 4, one of which
           may be shared by multiple symbols, and it avoids the need for a GOT
           entry for the referenced symbol, so it's more likely to be a win.
--
       -multilib-library-pic
           Link with the (library, not FD) pic libraries.  It's implied by
           -mlibrary-pic, as well as by -fPIC and -fpic without -mfdpic.  You
           should never have to use it explicitly.

--
           on *-*-linux-*android* targets.

           When compiling, this option enables -mbionic, -fPIC,
           -fno-exceptions and -fno-rtti by default.  When linking, this
           option makes the GCC driver pass Android-specific options to the
--
       -tno-android-cc
           Disable compilation effects of -mandroid, i.e., do not enable
           -mbionic, -fPIC, -fno-exceptions and -fno-rtti by default.

       -tno-android-ld
--
           of using a global offset table.  At present, this option implies
           -fpic, allowing at most a 16-bit offset for pc-relative addressing.
           -fPIC is not presently supported with -mpcrel, though this could be
           supported for 68020 and higher processors.

--
           different area of memory from the text segment.  This allows for
           execute-in-place in an environment without virtual memory
           management.  This option implies -fPIC.

       -mno-sep-data
--
           method.  This allows for execute-in-place and shared libraries in
           an environment without virtual memory management.  This option
           implies -fPIC.

       -mno-id-shared-library
--
           code that works if the GOT has more than 8192 entries.  This code
           is larger and slower than code generated without this option.  On
           M680x0 processors, this option is not needed; -fPIC suffices.

           GCC normally uses a single instruction to load values from the GOT.
--

           All -mabicalls code has traditionally been position-independent,
           regardless of options like -fPIC and -fpic.  However, as an
           extension, the GNU toolchain allows executables to use absolute
           accesses for locally-binding symbols.  It can also use shorter GP
--
           equivalent to -mgpopt=none.

           The default is -mgpopt except when -fpic or -fPIC is specified to
           generate position-independent code.  Note that the Nios II ABI does
           not permit GP-relative accesses from shared libraries.
--
           shared object is not actually shared across processes.  Instead of
           using -mimpure-text, you should compile all source code with -fpic
           or -fPIC.

       These switches are supported in addition to the above on Solaris 2:
#+end_example

**** How to tell the compiler about external header files?

Header files are *not compiled*.
They are _just included_ in source code when =#include= is used.

Before any compilation, the preprocessor assembles the complete files together with their includes.

The compiler look for header at specific places.
External headers locations should be added with the =-I= flag.

**** What is the difference between linking a library and adding an include?

Adding an include directory, we specify where the compiler will look for header files.
Those files contain /declarations/ of types or functions.

In case of a library, we can have static library or dynamic.

Static libraries have the object code of the functions that your code will link to.
If you only include the headers, then the compiler will not find the definitions of the declared entities.

Static libraries you have to explicitly link against them.
So we need an object file to link to.
Usually we have to compile the static library first, so we can then link it to our code using the same C++ runtime library.

Dynamic, or import, libraries contain all the code of the library.
When your code call something inside a dynamic library, the linker will look the the =.dll=.

* CMake
** Introduction

CMake is a system that *manages* the build process (configures the project) of a executable or library.

Its main input is a "generic" project description which allows a platform agnostic 

** CMake process overview


#+DOWNLOADED: screenshot @ 2021-07-21 09:49:26
#+attr_html: :width 550px
[[file:images/CMake/2021-07-21_09-49-26_screenshot.png]]


** Questions
*** What is the build process?

The build process consist of _configuring and generating project files_, the /setup stage/.
These project files work together with a native build tools (make for Linux, visual studio, ninja).
_It substitute the manual creation of Makefiles._

*** How CMake works?

CMake uses =CMakeLists.txt= file in the source directory with configuration to generate "standard build files", e.g. makefiles on Linux and projects/workspaces on Windows.

CMake can create /native build environment/ (for a specific system) to compile the source code, /create libraries/ (?), 
A build environment is what a _specific system_ uses to create executables from source code and libraries as well.
_The build files contain calls to the compiler._

In Linux, the command =make= is responsible for that, whereas in windows, visual studio handles the build process.

A typical =CMakeLists.txt= would contain:

#+begin_example
cmake_minimum_required(version x.x)

project(project_name)

add_executable(project_name main.cpp)
#+end_example


Reference: [[https://tuannguyen68.gitbooks.io/learning-cmake-a-beginner-s-guide/content/chap1/chap1.html][Tutorial 1: Let&apos;s start with CMake | Learning CMake: A beginner&apos;s g...]]


*** What is the difference between compiler, build system and CMake?

*Compiler* is the program that transforms the source code in a executable one.
For example, =gcc=, =clang= and so on.

Over time, there were so many flags been passed to the compiler that it was inconvenient to type them every time.
People starting creating a script with those compiler calls.
This evolved to the "_build system_", =make= or =ninja=.

Without a build system a project is just a collection of files.

When people wanted the support their software on multiple platforms and different compilers, the build system became too error prone and hard to maintain.
Then, they created a "meta" build system, something to create the build system depending on the environment.
For example =CMake= and =Autotools=.


1. [[https://stackoverflow.com/questions/39761924/understanding-roles-of-cmake-make-and-gcc][makefile - Understanding roles of CMake, make and GCC - Stack Overflow]]

*** What is a project setup?

A build system transforms a collection of files into a coherent project.
CMake uses =CMakeLists.txt= to define what should be built, how is built, what tests to run and what packages to create.
It contain a /description/ of the project.

A project has a source directory, =src=, and a binary directory =bin= (aka build directory).
The binary directory is the destination of everything the build system creates, e.g. executables, libraries, test output and packages.

*** What is a file generator?

Makefiles, visual studio and ninja.
CMake produce /project files/ that are adequate to a particular file generator depending o the system.

The project files creating involves 1) configuring and 2) generating.

*** What is the source and build directory?
The source directory is where the source code is and usually is under version control.

=CMakeLists.txt= is located in the source directory.

The binary directory is where everything producing during build is created.

CMake uses "binary directory" as interchangeable with "build directory".

*** What is built during the build process?

Executables, libraries, test outputs, packages.
All inside the =/build/= folder.

The _build tools's files_ are also created inside the =/build/= folder, =Makefiles= for instance.

*** Where should the =/build/= folder be in relation to the source?

Sub directory inside the source folder.

Or, completely separate in a different folder from the source.

*** What is =CMakeCache.txt=?
A file CMake creates in the build folder.
CMake uses information in this file for subsequent runs.

*** Does CMake builds the project?

It is primarily used in the setup phase.
But it can also call the build tool with =cmake --build <build files> --targer MyApp=.

A complete workflow would be, inside the source of a project,

#+begin_src shell
mkdir build
cd build
cmake ..
cmake --build .
#+end_src

*** What is Boost?
Boost is a set of libraries for C++ that provides support for tasks related to linear algebra, multithreading, unit testing and other.

Boost serialization, for instance, means "reversible deconstruction of an arbitrary set of C++ data structures to a sequence of bytes".

[[https://www.boost.org/doc/libs/1_76_0/doc/html/program_options.html][Program options]], also provided by boost, allows developers to obtain "program options".
This is (name, value) pairs from the user via command line or config files.

** Using CMake
*** Basic setup
If we want to build our =main.cpp= with the content:

#+begin_src C++ :tangle main.cpp
#include <iostream>
#include "mymath.h"

int main() {
std::cout << reciprocal(2.); 
}
#+end_src

where the header =mymath.h= has the declaration of the function =reciprocal= and the file =mymath.cpp= has its implementation 

#+begin_src C++ :tangle "mymath.h" :main no
double reciprocal (double x);
#+end_src


#+begin_src C++ :tangle mymath.cpp :main no
#include "mymath.h"

double reciprocal (double x) { return 1. / x; }
#+end_src

The files are:

| main.cpp   |
| mymath.cpp |
| mymath.h   |


Then, we create an empty =CMakeLists.txt= file on the source code.


#+RESULTS:
#+begin_example
CMakeLists.txt
main.cpp
mymath.cpp
mymath.h
#+end_example

Then, to get out our configured build system from CMake we create a separate =/build/= folder and run =cmake= on our source code:
The =-S= is where =CMakeList.txt= is.

#+begin_src shell :results output
mkdir build			# create build directory
cd build			# go to the build directory
cmake -S ../ -B .		# Source and Build directories
ls 
#+end_src

#+RESULTS:
#+begin_example
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build
CMakeCache.txt
CMakeFiles
Makefile
cmake_install.cmake
#+end_example

Inside the build directory a =Makefile= was created by CMake with the content,

#+begin_src shell
cd build
head --lines=20 Makefile	# limit to only the first 20 lines
#+end_src

#+RESULTS:
#+begin_example
# CMAKE generated file: DO NOT EDIT!
# Generated by "Unix Makefiles" Generator, CMake Version 3.20

# Default target executed when no arguments are given to make.
default_target: all
.PHONY : default_target

# Allow only one "make -f Makefile2" at a time, but pass parallelism.
.NOTPARALLEL:

#=============================================================================
# Special targets provided by cmake.

# Disable implicit rules so canonical targets will work.
.SUFFIXES:

# Disable VCS-based implicit rules.
% : %,v

# Disable VCS-based implicit rules.
#+end_example

This =Makefile= created by CMake has a bunch of predefined defaults even with the =CMakeLists.txt= empty.
If we try to =build= our project with this =Makefile=, we get nothing because there was no mention of our code in it.
However there are no errors in the process.

#+begin_src shell
cd build
make
ls
#+end_src

#+RESULTS:
: -- Configuring done
: -- Generating done
: -- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build
: CMakeCache.txt
: CMakeFiles
: Makefile
: cmake_install.cmake

Reference: [[https://cmake.org/cmake/help/git-stage/guide/tutorial/index.html][CMake Tutorial — CMake 3.20.20210421-g8d4c864 Documentation]]

*** Adding information to =CMakeLists.txt=

Now, if we have a =CMakeLists.txt= with just a reference to our main file

#+begin_example
cmake_minimum_required(VERSION 3.17)

project(myproject)

add_executable(project_name main.cpp)
#+end_example

and run =cmake= to configure our project

#+begin_src shell
mkdir build2
cd build2
cmake -S ../ -B .
#+end_src


#+RESULTS:
#+begin_example
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build2
#+end_example

now, if we build with =make= 

#+begin_src shell
cd build2
make
#+end_src

#+RESULTS:

=main.cpp:(.text+0x15): undefined reference to `reciprocal(double)'=

we get an error saying that a reference is undefined.


*** Adding multiple sources to =CMakeLists.txt=
Adding a reference to the file with the function definition.

#+begin_example
cmake_minimum_required(VERSION 3.17)

project(myproject)

add_executable(project_name main.cpp mymath.cpp)
#+end_example

#+begin_src shell
mkdir build3
cd build3
cmake -S ../ -B .
make
#+end_src

#+RESULTS:
#+begin_example
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build3
[ 33%] Building CXX object CMakeFiles/project_name.dir/main.cpp.o
[ 66%] Building CXX object CMakeFiles/project_name.dir/mymath.cpp.o
[100%] Linking CXX executable project_name
[100%] Built target project_name
#+end_example

and we can run the code by calling the executable
#+begin_src shell
cd build3
./project_name
#+end_src

#+RESULTS:
: 0.5

*** Adding a dynamic library to =CMakeLists.txt=

Now we want to compile our project using a ready to use dynamic library created by someone else.
For the example lets compile our dynamic/shared library with the function definition.

#+begin_src shell
clang++ -shared -o libmymath.so mymath.cpp
ls
#+end_src

The resulting folder structure is

#+RESULTS:
#+begin_example
CMakeLists.txt
libmymath.so
main.cpp
mymath.cpp
mymath.h
#+end_example

Now, with our dynamic library =libmymath.so= ready, let's include it on our project.

In order to /import/ a library into another project we use the concept of importing targets [[https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/Exporting-and-Importing-Targets][Exporting and Importing Targets · Wiki · CMake / Community · GitLab]].
The command =add_library= when importing from an outside library must have the =IMPORTED= option together with the library type =SHARED= or =STATIC=.
Then we need to tell CMake where this library is located with the =set_property= command.

#+begin_example
cmake_minimum_required(VERSION 3.17)

project(myproject)

add_library(libmymath SHARED IMPORTED)
set_property(TARGET libmymath PROPERTY IMPORTED_LOCATION ../libmymath.so)

add_executable(project_name main.cpp)

target_link_libraries(myproject libmymath)
#+end_example

When we run =cmake= with that, it will add a rule to link the library to the project executable.

#+begin_src shell
mkdir build4
cd build4
cmake -S ../ -B .
make
#+end_src

#+RESULTS:
#+begin_example
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Check for working C compiler: /usr/bin/cc - skipped
-- Detecting C compile features
-- Detecting C compile features - done
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /mnt/c/Users/nasse/OneDrive/nasser-website/content/notes/cpp-notes/build4
[ 50%] Building CXX object CMakeFiles/myproject.dir/main.cpp.o
[100%] Linking CXX executable myproject
[100%] Built target myproject
#+end_example

Then running the generated executable

#+begin_src shell
cd build4
./myproject
#+end_src

#+RESULTS:
: 0.5

** Questions
*** Changed installation path, need to rerun =cmake= and =make=?

No, just =make install DESTDIR=<new path=.


*** When should I rerun =cmake=?

The build targets created by =cmake= automatically include checks for each file.
When =make= is called, it will re run =cmake= if necessary.

If you change build settings, then you need to re run =cmake=.
=--target clean= to remove old files.

*** What is CMake cache?
It refers to persistent variables in the file =CMakeCache.txt= in the build directory.

It contains the user configurable options.


* Design principles
** Policy based design
** Free functions versus member functions

* References
# jason turner


- Stroustrup, B. (2014). Programming: principles and practice using C++. Upper Saddle River, NJ: Addison-Wesley.
- Stroustrup, B., & Stroustrup, B. (2014). A tour of C++. Upper Saddle River, NJ: Addison-Wesley.
- Scott, C. (). Professional CMake. : .
- [[https://github.com/AnthonyCalandra/modern-cpp-features][GitHub - AnthonyCalandra/modern-cpp-features: A cheatsheet of modern C++ lang...]]



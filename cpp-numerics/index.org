#+title: C++ numerics 
#+date: <2021-05-31 Mon>
#+author: Nasser Alkmim
#+draft: t
#+toc: t
#+tags[]: c++
* Prologue
Bellow are my notes on using C++ for numerical applications.
Multiple sources are used, I will cite them at the end or whenever appropriate.

I'm using org-mode with org-babel to document as many details as possible for it to be reproducible.

#+begin_src emacs-lisp
(print  org-version)
#+end_src

#+RESULTS:
: 9.4.6

#+begin_src shell
g++ --version
#+end_src

#+RESULTS:
: g++ (Ubuntu 9.4.0-1ubuntu1~20.04) 9.4.0
: Copyright (C) 2019 Free Software Foundation, Inc.
: This is free software; see the source for copying conditions.  There is NO
: warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
: 

* Eigen
:PROPERTIES:
:header-args:C++: :flags -I ~/eigen/
:END:
** What is it?
A template library for linear algebra.
It has clean and elegant API.
** How get it?
Download and extract Eigen's source code from the git repository.

#+begin_src shell
cd ~
git clone https://gitlab.com/libeigen/eigen.git
#+end_src

#+RESULTS:

#+begin_src shell
cd ~/eigen
ls -la
#+end_src

#+RESULTS:
#+begin_example
total 244
drwxr-xr-x 17 nasser nasser  4096 Jun  2 07:50 .
drwxr-xr-x 21 nasser nasser  4096 Jun  2 07:49 ..
drwxr-xr-x  8 nasser nasser  4096 Jun  2 07:50 .git
-rw-r--r--  1 nasser nasser   292 Jun  2 07:50 .gitignore
drwxr-xr-x  4 nasser nasser  4096 Jun  2 07:50 .gitlab
-rw-r--r--  1 nasser nasser   571 Jun  2 07:50 .gitlab-ci.yml
-rw-r--r--  1 nasser nasser   180 Jun  2 07:50 .hgeol
-rw-r--r--  1 nasser nasser 24557 Jun  2 07:50 CMakeLists.txt
-rw-r--r--  1 nasser nasser 11362 Jun  2 07:50 COPYING.APACHE
-rw-r--r--  1 nasser nasser  1517 Jun  2 07:50 COPYING.BSD
-rw-r--r--  1 nasser nasser 35147 Jun  2 07:50 COPYING.GPL
-rw-r--r--  1 nasser nasser 26530 Jun  2 07:50 COPYING.LGPL
-rw-r--r--  1 nasser nasser  2193 Jun  2 07:50 COPYING.MINPACK
-rw-r--r--  1 nasser nasser 16726 Jun  2 07:50 COPYING.MPL2
-rw-r--r--  1 nasser nasser   779 Jun  2 07:50 COPYING.README
-rw-r--r--  1 nasser nasser   584 Jun  2 07:50 CTestConfig.cmake
-rw-r--r--  1 nasser nasser   180 Jun  2 07:50 CTestCustom.cmake.in
drwxr-xr-x  3 nasser nasser  4096 Jun  2 07:50 Eigen
-rw-r--r--  1 nasser nasser  1145 Jun  2 07:50 INSTALL
-rw-r--r--  1 nasser nasser   288 Jun  2 07:50 README.md
drwxr-xr-x  6 nasser nasser  4096 Jun  2 07:50 bench
drwxr-xr-x  5 nasser nasser  4096 Jun  2 07:50 blas
drwxr-xr-x  2 nasser nasser  4096 Jun  2 07:50 ci
drwxr-xr-x  2 nasser nasser  4096 Jun  2 07:50 cmake
drwxr-xr-x  4 nasser nasser  4096 Jun  2 07:50 debug
drwxr-xr-x  5 nasser nasser  4096 Jun  2 07:50 demos
drwxr-xr-x  5 nasser nasser  4096 Jun  2 07:50 doc
-rw-r--r--  1 nasser nasser   254 Jun  2 07:50 eigen3.pc.in
drwxr-xr-x  2 nasser nasser  4096 Jun  2 07:50 failtest
drwxr-xr-x  2 nasser nasser  4096 Jun  2 07:50 lapack
drwxr-xr-x  2 nasser nasser  4096 Jun  2 07:50 scripts
-rw-r--r--  1 nasser nasser   216 Jun  2 07:50 signature_of_eigen3_matrix_library
drwxr-xr-x  2 nasser nasser 12288 Jun  2 07:50 test
drwxr-xr-x  6 nasser nasser  4096 Jun  2 07:50 unsupported
#+end_example

** How to use it?

Because it is a header only, you only need to _tell the compiler where those header files are_.
There is no library to link to.

We do that by using the compiler flag =-I <path>= to include a path.
In a org-mode source block we use the =:flags= header argument.

#+begin_src C++ :flags -I ~/eigen/
#include <iostream>
#include <Eigen/Dense>

int main () {
Eigen::Matrix<double, 2, 2> A;
A << 2, 2, 3, 4;
std::cout << A;
}
#+end_src

#+RESULTS:
: 2 2
: 3 4


Only problem is that =lsp-org= is not aware of the library file.


** Using with sub-tree properties header arguments
:PROPERTIES:
:header-args:C++: :flags -I ~/eigen/
:END:

Using the following properties for the sub-tree.
#+begin_example
:PROPERTIES:
:header-args:C++: :flags -I ~/eigen/
END:
#+end_example

This way, I don't need to write the compiler flag on the src-blocks under this sub-tree.

#+begin_src C++
#include <iostream>
#include <Eigen/Dense>

int main () {
Eigen::Matrix<double, 2, 2> A;
A << 2, 2, 3, 4;
std::cout << A;
}
#+end_src

#+RESULTS:
: 2 2
: 3 4

** Adding it to the =/usr/local/include= folder via symlink

The =/usr/local/include= is the directory where local programs are placed to they can be found by the compiler when included.
The local directory is used to install a library _outside_ of the context of the package manager (=apt=).

#+begin_src shell
sudo ln -s ~/eigen /usr/local/include
#+end_src

#+RESULTS:

We can see the symbolic link with with

#+begin_src shell
ls -l /usr/local/include | grep eigen
#+end_src

#+RESULTS:
: lrwxrwxrwx 1 root root    18 Jun  2 08:22 eigen -> /home/nasser/eigen

Does not work with out of the box with org-babel.
From [[https://wiki.freebsd.org/WarnerLosh/UsrLocal][WarnerLosh/UsrLocal - FreeBSD Wiki]], we can see that =clang= and =gcc= have include paths containing =/usr/include= by default but not =/usr/local/include=.
Org-babel is using =g++= by default =(print org-babel-C++-compiler)"g++".=
=gcc= is the compiler collections from the GNU project and =g++= is the command to compile a C++ program.

Where is =gcc= looking for header files?
#+begin_src shell
cpp -v
#+end_src

#+RESULTS:
: # 1 "<stdin>"
: # 1 "<built-in>"
: # 1 "<command-line>"
: # 31 "<command-line>"
: # 1 "/usr/include/stdc-predef.h" 1 3 4
: # 32 "<command-line>" 2
: # 1 "<stdin>"

#+begin_src C++
#include <iostream>
#include <Eigen/Dense>

int main () {
Eigen::Matrix<double, 2, 2> A;
A << 2, 2, 3, 4;
std::cout << A;
}
#+end_src

#+RESULTS:

** What is =Eigen/Dense=

It is a header file that includes multiple other header files, Core, Geometry, LU and so on.
The Core header contains the Matrix and Array classes.

All classes defined in the =Eigen/Dense= header file are in the =Eigen= namespace.
** =Matrix= template

Base template: =Matrix< TYPE, ROWS, COLUMNS, OPTIONS> name;.=


** What is the difference between =Matrix= and =Vector=?

All matrices and vectors are objects of the =Matrix= template class.
=Vector= is a special case of matrices.

#+begin_src C++
#include <iostream>
#include <Eigen/Dense>

int main () {
  Eigen::Matrix<float, 3, 1> vec1{1, 2, 3};
  std::cout << vec1 << std::endl;
  Eigen::Vector3f vec {4, 6, 5};
  std::cout << vec;
}
#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: 6
: 5

** What is the difference between =Matrix= and =MatrixXd=?

=MatrixXd= can have arbitrary dimension with every entry a double.
Is the most used type of matrix.

Eigen has _convenient typedefs_ for Matrix and Vector creating that are less verbose.
=Matrix<float,Dynamic,Dynamic>   <=>   MatrixXf= for instance.

#+begin_src C++
#include <iostream>
#include <Eigen/Dense>

int main () {
  Eigen::MatrixXd m {Eigen::MatrixXd::Random(2,2) * 50};	// 2 by 2 size matrix
  std::cout << m;
}
#+end_src

#+RESULTS:
:  34.0188  28.3099
: -10.5617   29.844

Remarks:
1. because the object can have arbitrary size, the size is set at run time;
2. fixed size has advantage of been faster
3. however using many types increases compilation time


** Comma initialization

It is a way to specify element values.

#+begin_src C++
#include <iostream>
#include "Eigen/Dense"

int main () {
  Eigen::Matrix3f m;
  m << 1, 2, 3,
	4, 5, 6,
	7, 8, 9;
  std::cout << m;
}
#+end_src

#+RESULTS:
: 1 2 3
: 4 5 6
: 7 8 9

** Matrix-matrix multiplication

The factor should have the same TYPE elements.

#+begin_src C++
#include <iostream>
#include <Eigen/Dense>

int main () {
  Eigen::Matrix2d M;
  M << 1, 2, 3, 4 ;
  Eigen::Vector2d v {1, 1};
  std::cout << M << std::endl;
  std::cout << v << std::endl;
  std::cout << M*M << std::endl;
  std::cout << M*v;
}
#+end_src

#+RESULTS:
: 1 2
: 3 4
: 1
: 1
:  7 10
: 15 22
: 3
: 7

** Dot product

Remarks:
1. adjoint is the conjugate transpose.

#+begin_src C++
#include <iostream>
#include <Eigen/Dense>

int main () {
  Eigen::Vector2d v {1, 2};
  std::cout << v.transpose()*v << std::endl;
  std::cout << v.dot(v) << std::endl;
  std::cout << v.adjoint()*v << std::endl;
}
#+end_src

#+RESULTS:
: 5
: 5
: 5

* Technicalities
** What is rounding error?
When approximate the real numbers with a computer the mathematical exactness is lost.
#+begin_src C++
#include <iostream>

int main () {
int v {33333};
double a {1./v};
std::cout << a << std::endl;
double sum {0};
for (int i=0; i<v; ++i) sum += a;
std::cout << sum;
}
#+end_src

#+RESULTS:
: 3.00003e-05
: 1

** What is the difference between double and float?
Float uses 4 byte storage and double 8.
Double has precision of 15 decimal plates whereas float only 6.

#+begin_src C++
#include <iostream>
#include <ostream>

int main () {
float f_var;
double d_var;
std::cout << sizeof(f_var) << std::endl;
std::cout << sizeof(d_var) << std::endl;
}
#+end_src

#+RESULTS:
: 4
: 8

** What it means that an integer overflows?
When it loses the most significant bit


** Arrays
*** What is it?
Sequence of elements.
*** Built-in array
Advantages:
1. direct mapping to hardware
2. efficient for low level operations
   
Disadvantages
1. fixed sizes (fixed at compiled time)
2. can not be passes in a clean way
   1. arrays turns into a pointer to the first element
   2. can not pass a general size =void foo(int [][]);=
3. no range checking
4. no array operations

#+begin_src C++
#include <iostream>

int main () {
int ai[4];
std::cout << ai[0] << ai[1] << ai[2];
double ad[3][4];
}
#+end_src

#+RESULTS:
: -39477363232767496910938



